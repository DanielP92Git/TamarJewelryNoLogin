---
phase: 23-foundation-infrastructure
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - backend/models/Product.js
  - backend/migrations/20260210000000-add-product-slugs.js
autonomous: true

must_haves:
  truths:
    - "Every product in MongoDB has a unique slug field"
    - "The slug migration script can be re-run safely (idempotent)"
    - "Slugs are generated from English product names using counter-based collision handling"
  artifacts:
    - path: "backend/models/Product.js"
      provides: "Slug field on Product schema with sparse unique index"
      contains: "slug:"
    - path: "backend/migrations/20260210000000-add-product-slugs.js"
      provides: "Idempotent migration that generates slugs for all existing products"
      exports: ["up", "down"]
  key_links:
    - from: "backend/models/Product.js"
      to: "MongoDB"
      via: "sparse unique index on slug"
      pattern: "slug.*unique.*sparse"
    - from: "backend/migrations/20260210000000-add-product-slugs.js"
      to: "slugify"
      via: "npm slugify library"
      pattern: "require\\('slugify'\\)"
---

<objective>
Add a slug field to the Product schema and create an idempotent migration script that generates URL-friendly slugs for all existing products from their English names.

Purpose: Product slugs are required for clean SEO URLs (e.g., /en/product/gold-star-necklace). Without slugs, Phase 25 cannot build product detail pages.
Output: Product model with slug field + sparse unique index, migration script that generates slugs with counter-based collision handling.
</objective>

<execution_context>
@C:/Users/pagis/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/pagis/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/23-foundation-infrastructure/23-RESEARCH.md
@backend/models/Product.js
@backend/migrations/20260201194100-add-product-display-order.js
@backend/migrate-mongo-config.js
@backend/package.json
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add slug field to Product schema</name>
  <files>backend/models/Product.js, backend/package.json</files>
  <action>
  1. Install slugify: `cd backend && npm install slugify`

  2. In backend/models/Product.js, add the slug field to ProductSchema AFTER the displayOrder field:
     ```javascript
     slug: {
       type: String,
       trim: true,
       sparse: true,
       unique: true,
       lowercase: true,
       maxLength: [120, 'Slug must be at most 120 characters'],
       validate: {
         validator: function(v) {
           if (!v) return true;
           return /^[a-z0-9]+(?:-[a-z0-9]+)*$/.test(v);
         },
         message: 'Slug must contain only lowercase letters, numbers, and hyphens'
       }
     }
     ```

  3. Add the explicit sparse unique index for slug (same pattern as the SKU index):
     ```javascript
     ProductSchema.index({ slug: 1 }, { unique: true, sparse: true, name: 'product_slug_unique_idx' });
     ```

  4. Add a pre-save hook that auto-generates slug for new products (AFTER the existing displayOrder pre-save hook). Use slugify library:
     ```javascript
     const slugify = require('slugify');

     ProductSchema.pre('save', async function(next) {
       // Only generate slug for new documents without one
       if (this.isNew && !this.slug && this.name) {
         const Product = this.constructor;
         const baseSlug = slugify(this.name, { lower: true, strict: true });

         // Check for collisions and use counter-based approach
         let finalSlug = baseSlug;
         let counter = 1;
         while (await Product.findOne({ slug: finalSlug })) {
           counter++;
           finalSlug = `${baseSlug}-${counter}`;
         }
         this.slug = finalSlug;
       }
       next();
     });
     ```

  Slugs are IMMUTABLE after creation — the pre-save hook only runs for new documents (this.isNew). This preserves bookmarks, backlinks, and SEO authority per research recommendation.

  The `require('slugify')` should be at the top of the file with other requires.
  </action>
  <verify>`cd backend && node -e "const Product = require('./models/Product'); console.log(Product.schema.paths.slug ? 'slug field exists' : 'MISSING')"` should print "slug field exists". Run `npm test` to confirm existing tests pass.</verify>
  <done>Product schema has slug field with sparse unique index, lowercase validation, and auto-generation pre-save hook for new products.</done>
</task>

<task type="auto">
  <name>Task 2: Create idempotent slug migration script</name>
  <files>backend/migrations/20260210000000-add-product-slugs.js</files>
  <action>
  Create `backend/migrations/20260210000000-add-product-slugs.js` following the existing migration pattern from `20260201194100-add-product-display-order.js`:

  ```javascript
  const slugify = require('slugify');

  module.exports = {
    async up(db) {
      const products = db.collection('products');

      // 1. Ensure sparse unique index (idempotent: createIndex is a no-op if exists)
      await products.createIndex(
        { slug: 1 },
        { unique: true, sparse: true, name: 'product_slug_unique_idx' }
      );
      console.log('Ensured unique sparse index on slug field');

      // 2. Find products without slugs (idempotent: skips already-slugged products)
      const needSlugs = await products.find({
        $or: [
          { slug: { $exists: false } },
          { slug: null },
          { slug: '' }
        ]
      }).toArray();

      console.log(`Found ${needSlugs.length} products needing slugs`);

      if (needSlugs.length === 0) {
        console.log('All products already have slugs. Migration is idempotent — nothing to do.');
        return;
      }

      // 3. Load existing slugs to detect collisions
      const existingSlugs = new Set();
      const withSlugs = await products.find(
        { slug: { $exists: true, $ne: null, $ne: '' } },
        { projection: { slug: 1 } }
      ).toArray();
      for (const p of withSlugs) {
        existingSlugs.add(p.slug);
      }

      // 4. Generate slugs with counter-based collision handling
      let generated = 0;
      for (const product of needSlugs) {
        const name = product.name || `product-${product.id || product._id}`;
        const baseSlug = slugify(name, {
          lower: true,
          strict: true,
          remove: /[*+~.()'"!:@]/g
        });

        let finalSlug = baseSlug;
        let counter = 1;

        // Check against both existing DB slugs and newly assigned slugs
        while (existingSlugs.has(finalSlug)) {
          counter++;
          finalSlug = `${baseSlug}-${counter}`;
        }

        // Mark as used
        existingSlugs.add(finalSlug);

        // Update product
        await products.updateOne(
          { _id: product._id },
          { $set: { slug: finalSlug } }
        );
        generated++;
      }

      console.log(`Migration complete: ${generated} products now have slugs`);

      // 5. Verify all products have slugs
      const remaining = await products.countDocuments({
        $or: [
          { slug: { $exists: false } },
          { slug: null },
          { slug: '' }
        ]
      });
      if (remaining > 0) {
        console.warn(`WARNING: ${remaining} products still without slugs`);
      }
    },

    async down(db) {
      const products = db.collection('products');

      // Drop index
      try {
        await products.dropIndex('product_slug_unique_idx');
        console.log('Dropped slug index');
      } catch (err) {
        console.log('Index may not exist, continuing...');
      }

      // Remove slug field from all products
      const result = await products.updateMany(
        {},
        { $unset: { slug: '' } }
      );
      console.log(`Rollback complete: removed slug from ${result.modifiedCount} products`);
    }
  };
  ```

  Key design decisions:
  - English product names used as slug source (global SEO, per research recommendation)
  - Counter-based collision: "necklace", "necklace-2", "necklace-3" (readable URLs)
  - Idempotent: only processes products without slugs, skips already-slugged ones
  - Tracks existing slugs in memory Set for fast collision detection
  - Follows existing migration pattern (up/down, console.log progress)
  - Uses migrate-mongo framework (already configured in project)
  </action>
  <verify>
  Run `cd backend && node -e "const m = require('./migrations/20260210000000-add-product-slugs.js'); console.log(typeof m.up === 'function' && typeof m.down === 'function' ? 'OK' : 'FAIL')"` to confirm the migration exports up/down functions.
  Verify idempotency conceptually: the $or query for missing slugs means re-running on a fully-migrated DB finds 0 products and exits early.
  Run `npm test` to confirm existing tests pass.
  </verify>
  <done>Migration script exists at backend/migrations/20260210000000-add-product-slugs.js with up() that generates counter-based slugs for all products missing them, and down() that removes slugs and drops the index. Re-running up() on an already-migrated DB is a safe no-op.</done>
</task>

</tasks>

<verification>
1. `grep "slug" backend/models/Product.js` — slug field defined with validation
2. `grep "product_slug_unique_idx" backend/models/Product.js` — index declared
3. `ls backend/migrations/20260210000000-add-product-slugs.js` — migration exists
4. `grep "idempotent" backend/migrations/20260210000000-add-product-slugs.js` — idempotency documented
5. Existing tests pass: `cd backend && npm test`
</verification>

<success_criteria>
- Product schema has slug field with sparse unique index and lowercase validation
- New products automatically get slugs via pre-save hook
- Slugs are immutable (hook only fires on isNew)
- Migration script generates slugs from English names with counter-based collision handling
- Migration is idempotent (re-running is a safe no-op)
- All 419 existing tests continue to pass
</success_criteria>

<output>
After completion, create `.planning/phases/23-foundation-infrastructure/23-02-SUMMARY.md`
</output>

---
phase: 14-file-upload--image-processing-tests
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - backend/tests/helpers/imageHelpers.js
  - backend/tests/integration/file.validation.test.js
autonomous: true

must_haves:
  truths:
    - "Test image helpers generate valid JPEG, PNG, and WebP buffers processable by Sharp"
    - "Upload endpoint rejects files with unsupported MIME types (PDF, BMP, SVG) with 415 status"
    - "Upload endpoint rejects files exceeding size limit with 413 status and LIMIT_FILE_SIZE code"
    - "Upload endpoint requires admin authentication and rejects unauthenticated requests"
    - "Upload endpoint rejects requests with no files or no main image with 400 status"
  artifacts:
    - path: "backend/tests/helpers/imageHelpers.js"
      provides: "Programmatic test image generation (JPEG, PNG, WebP, corrupt, oversized)"
      exports: ["createTestJPEG", "createTestPNG", "createTestWebP", "createCorruptImage", "createOversizedBuffer"]
    - path: "backend/tests/integration/file.validation.test.js"
      provides: "Upload validation integration tests covering FILE-01 through FILE-04"
      min_lines: 100
  key_links:
    - from: "backend/tests/helpers/imageHelpers.js"
      to: "sharp"
      via: "Sharp create API for programmatic image generation"
      pattern: "sharp.*create"
    - from: "backend/tests/integration/file.validation.test.js"
      to: "/upload"
      via: "supertest .attach() for multipart file upload"
      pattern: "request.*post.*upload.*attach"
---

<objective>
Create image test helper utilities and file upload validation integration tests.

Purpose: Establish reusable image generation helpers using Sharp and test the Multer validation layer (MIME types, file size limits, file count limits, auth requirements) for the /upload endpoint. Covers FILE-01 (valid MIME acceptance), FILE-02 (invalid MIME rejection), FILE-03 (size limit enforcement), FILE-04 (oversized file rejection).

Output: `imageHelpers.js` helper module + `file.validation.test.js` integration test file
</objective>

<execution_context>
@C:\Users\pagis\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\pagis\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/14-file-upload--image-processing-tests/14-CONTEXT.md
@.planning/phases/14-file-upload--image-processing-tests/14-RESEARCH.md

Key backend references:
@backend/index.js (lines 757-825 for Multer config, lines 3068-3254 for /upload endpoint, lines 3938-3960 for error handler)
@backend/tests/setup.js
@backend/tests/helpers/mocks/index.js
@backend/tests/helpers/mocks/s3.js
@backend/tests/helpers/factories.js
@backend/tests/helpers/authHelpers.js
@backend/tests/integration/paypal.orders.test.js (for pattern reference)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create image test helper utilities</name>
  <files>backend/tests/helpers/imageHelpers.js</files>
  <action>
Create `backend/tests/helpers/imageHelpers.js` that provides programmatic test image generation using Sharp. This module generates valid and invalid image buffers on-demand (no fixture files stored in repo).

Functions to implement:

1. `createTestJPEG(width = 100, height = 100)` - Returns a Buffer of a valid JPEG image with solid color background. Use `sharp({ create: { width, height, channels: 3, background: { r: 255, g: 100, b: 100 } } }).jpeg({ quality: 80 }).toBuffer()`.

2. `createTestPNG(width = 100, height = 100)` - Returns a Buffer of a valid PNG image with alpha channel. Use `channels: 4, background: { r: 100, g: 255, b: 100, alpha: 1 }` and `.png()`.

3. `createTestWebP(width = 100, height = 100)` - Returns a Buffer of a valid WebP image. Use `channels: 3, background: { r: 100, g: 100, b: 255 }` and `.webp({ quality: 85 })`.

4. `createCorruptImage()` - Creates a valid JPEG buffer then truncates it to ~30% of original size. Returns the truncated Buffer. This simulates a corrupt/incomplete image download.

5. `createOversizedBuffer(targetSizeMB = 60)` - Creates a large JPEG buffer that exceeds the upload size limit. Use a large dimension and `quality: 100` to maximize file size. Note: exact byte size may vary due to JPEG compression, so target well above the limit.

6. `verifyImageBuffer(buffer)` - Utility to check if a buffer is a valid image by running `sharp(buffer).metadata()`. Returns `{ valid: true, format, width, height }` or `{ valid: false, error }`.

All functions are async (return Promises). Export all functions as named exports.

Verify the helpers work by adding a self-test at the bottom as a comment showing expected usage, but do NOT add actual test execution code.
  </action>
  <verify>
Import the module in a Node.js context and verify:
- `createTestJPEG()` returns a Buffer > 0 bytes
- `createTestPNG()` returns a Buffer > 0 bytes
- `createTestWebP()` returns a Buffer > 0 bytes
- `createCorruptImage()` returns a Buffer that is smaller than the original JPEG
- `verifyImageBuffer(await createTestJPEG())` returns `{ valid: true, format: 'jpeg' }`

Run: `cd backend && npx vitest run --reporter=verbose 2>&1 | head -30` to verify no import errors.
  </verify>
  <done>imageHelpers.js exists with 6 exported async functions. All generate valid buffers that can be used by subsequent test files.</done>
</task>

<task type="auto">
  <name>Task 2: Write file upload validation integration tests</name>
  <files>backend/tests/integration/file.validation.test.js</files>
  <action>
Create `backend/tests/integration/file.validation.test.js` with integration tests for the /upload endpoint's validation behavior.

Follow the established test patterns from Phases 11-13:
- Import from vitest: `describe, it, expect, beforeAll, afterAll, beforeEach`
- Import `request` from `supertest`
- Import `mongoose` for User model access
- Import helpers: `validateTestEnvironment`, `disableNetConnect`, `cleanAllMocks`, `mockS3Upload` from mocks
- Import `createAdmin` from factories, `createAuthToken` from authHelpers
- Import image helpers: `createTestJPEG`, `createTestPNG`, `createTestWebP`, `createOversizedBuffer` from imageHelpers

Test structure:

```javascript
describe('File Upload Validation - /upload endpoint', () => {
  let app;
  let adminToken;

  beforeAll(async () => {
    validateTestEnvironment();
    disableNetConnect();

    const appModule = await import('../../index.js');
    app = appModule.app;

    // Create admin user for auth
    const User = mongoose.model('Users');
    const admin = createAdmin();
    await new User(admin).save();
    adminToken = createAuthToken(admin);
  });

  afterAll(() => { cleanAllMocks(); });

  beforeEach(() => {
    cleanAllMocks();
    // Mock S3 for tests that reach the upload stage
    mockS3Upload();
  });
```

**Test groups (use describe blocks):**

1. **Authentication (FILE-01 prerequisite):**
   - `should return 401 when no auth token provided` - POST /upload with .attach('mainImage', jpegBuffer, 'test.jpg'), no auth header, expect 401
   - `should return 403 when non-admin user uploads` - Create regular user token, expect 401 or 403

2. **Valid MIME type acceptance (FILE-01):**
   - `should accept JPEG image upload` - .attach('mainImage', jpegBuffer, 'photo.jpg'), set auth-token, expect 200
   - `should accept PNG image upload` - .attach('mainImage', pngBuffer, 'graphic.png'), expect 200
   - `should accept WebP image upload` - .attach('mainImage', webpBuffer, 'optimized.webp'), expect 200

3. **Invalid MIME type rejection (FILE-02):**
   - `should reject PDF files with 415` - Create a buffer with `Buffer.from('%PDF-1.4')`, attach as 'document.pdf', expect 415
   - `should reject BMP files` - Create a buffer with BMP magic bytes `Buffer.from([0x42, 0x4D, ...])`, attach as 'image.bmp', expect 415
   - `should reject SVG files` - Create buffer with `Buffer.from('<svg></svg>')`, attach as 'image.svg', expect 415
   - `should reject text files` - Create buffer with `Buffer.from('not an image')`, attach as 'file.txt', expect 415
   - Verify error response has `{ success: false, error: 'File type not supported' }`

4. **File size limits (FILE-03, FILE-04):**
   - `should reject files exceeding size limit with 413` - Use createOversizedBuffer(60), attach as 'huge.jpg', expect 413
   - Verify response has `{ success: false, code: 'LIMIT_FILE_SIZE' }` (from Multer error handler at line 3941)
   - Note: Testing "just under limit" requires a large buffer (49MB) which is slow and memory-heavy. Instead, test with a normal-sized image (which is well under limit) and verify acceptance.

5. **Missing files (upload validation):**
   - `should return 400 when no files uploaded` - POST /upload with auth but no .attach(), expect 400, verify `{ error: 'No files were uploaded' }`
   - `should return 400 when no main image provided` - Attach only smallImages (no mainImage field), expect 400, verify `{ error: 'No main image provided' }`

**Important implementation notes:**
- The backend error handler returns 415 (not 400) for "File type not supported" errors (line 3954)
- The Multer error handler returns 413 for LIMIT_FILE_SIZE (line 3941)
- The upload endpoint requires `fetchUser` + `requireAdmin` middleware
- S3 must be mocked even for validation tests that get past Multer, because processImage calls uploadFileToSpaces
- Use `nock.persist()` on S3 mocks if multiple upload attempts needed per test, or re-mock in beforeEach
  </action>
  <verify>
Run: `cd backend && npx vitest run tests/integration/file.validation.test.js --reporter=verbose`

Expected: All tests pass. Minimum ~12 tests covering:
- 2 auth tests (401/403)
- 3 valid MIME tests (JPEG, PNG, WebP acceptance)
- 4 invalid MIME tests (PDF, BMP, SVG, TXT rejection)
- 1 size limit test (oversized rejection)
- 2 missing file tests (no files, no main image)
  </verify>
  <done>file.validation.test.js exists with passing tests covering FILE-01 (valid MIME acceptance), FILE-02 (invalid MIME rejection), FILE-03/FILE-04 (size limit enforcement), and authentication requirements. All tests use mocked S3 and in-memory database.</done>
</task>

</tasks>

<verification>
1. Run full test suite: `cd backend && npx vitest run --reporter=verbose`
2. Confirm all existing tests still pass (no regressions)
3. Confirm new file.validation.test.js tests all pass
4. Verify no real S3 calls made (nock.disableNetConnect active)
5. Verify imageHelpers.js generates valid images (verifyImageBuffer returns valid: true)
</verification>

<success_criteria>
- imageHelpers.js provides 6 async functions for test image generation
- file.validation.test.js has 12+ passing tests covering FILE-01 through FILE-04
- JPEG, PNG, WebP acceptance verified via /upload endpoint
- PDF, BMP, SVG, TXT rejection verified with 415 status
- Oversized file rejection verified with 413 status and LIMIT_FILE_SIZE code
- Authentication enforcement verified (401 without token)
- Missing file scenarios verified (400 status)
- All existing tests remain passing
</success_criteria>

<output>
After completion, create `.planning/phases/14-file-upload--image-processing-tests/14-01-SUMMARY.md`
</output>

---
phase: 11-authentication-authorization-tests
plan: 03
type: execute
wave: 2
depends_on: ["11-01"]
files_modified:
  - backend/tests/integration/auth.protected.test.js
autonomous: true

must_haves:
  truths:
    - "Request without token returns 401"
    - "Request with valid token returns 200 and attaches user to request"
    - "Request with expired token returns 401"
    - "Request with malformed token returns 401"
  artifacts:
    - path: "backend/tests/integration/auth.protected.test.js"
      provides: "Protected route integration tests"
      contains: "describe('fetchUser middleware'"
  key_links:
    - from: "backend/tests/integration/auth.protected.test.js"
      to: "backend/middleware/auth.js"
      via: "fetchUser middleware tested via HTTP"
      pattern: "request\\(app\\).*set.*Authorization"
---

<objective>
Test fetchUser middleware through protected endpoints.

Purpose: Verify that protected routes correctly require authentication, accept valid JWT tokens, and reject invalid/expired/malformed tokens with appropriate error codes.

Output: Protected route integration test suite testing fetchUser middleware behavior via HTTP boundary.
</objective>

<execution_context>
@C:\Users\pagis\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\pagis\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Phase 11 research
@.planning/phases/11-authentication-a-authorization-tests/11-RESEARCH.md

# Auth helpers from Plan 01
@backend/tests/helpers/authHelpers.js

# Test infrastructure
@backend/tests/setup.js
@backend/tests/helpers/factories.js

# Source code to test
@backend/middleware/auth.js (fetchUser function)
@backend/index.js (endpoints using fetchUser)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create protected route integration tests</name>
  <files>backend/tests/integration/auth.protected.test.js</files>
  <action>
Create integration tests for fetchUser middleware by testing protected endpoints.

Use POST /getcart as the test endpoint (uses fetchUser but not requireAdmin).

Test structure:
```javascript
import { describe, it, expect, beforeAll, beforeEach } from 'vitest';
import request from 'supertest';
import mongoose from 'mongoose';
import { createUser } from '../helpers/factories.js';
import {
  createAuthToken,
  createExpiredToken,
  createInvalidToken,
  TEST_JWT_KEY
} from '../helpers/authHelpers.js';
import { validateTestEnvironment } from '../helpers/envGuard.js';
import { disableNetConnect, cleanAllMocks } from '../helpers/mocks/index.js';

// Ensure JWT_KEY is set before importing app
process.env.JWT_KEY = TEST_JWT_KEY;
```

Test cases to implement:

1. **No token (401):**
   - `should return 401 when no token provided`
     - GET /getcart without Authorization header
     - Expect 401, errors contains 'authenticate'

   - `should return 401 when Authorization header is empty`
     - Set Authorization: ''
     - Expect 401

2. **Valid token (200):**
   - `should return 200 with valid auth-token header`
     - Create user in DB
     - Generate token with createAuthToken(user)
     - Set header: auth-token: {token}
     - Expect 200

   - `should return 200 with valid Bearer token in Authorization header`
     - Create user in DB
     - Generate token
     - Set header: Authorization: Bearer {token}
     - Expect 200

   - `should attach correct user data to request`
     - Login and access protected endpoint
     - Verify response reflects user's data (cart contents)

3. **Invalid tokens (401):**
   - `should return 401 for expired token`
     - Create user
     - Generate expired token with createExpiredToken(user)
     - Expect 401

   - `should return 401 for token with invalid signature`
     - Create user
     - Generate token with createInvalidToken(user) (wrong secret)
     - Expect 401

   - `should return 401 for malformed token string`
     - Set Authorization: 'Bearer not-a-valid-jwt-at-all'
     - Expect 401

   - `should return 401 for token with missing user.id in payload`
     - Manually create token with payload missing user.id
     - Expect 401, errors: 'Invalid token'

4. **Token format handling:**
   - `should reject token without Bearer prefix in Authorization header`
     - Set Authorization: {token} (no Bearer prefix)
     - Expect 401 (fetchUser requires "Bearer " prefix or auth-token header)

   - `should accept token via auth-token header without Bearer prefix`
     - Set auth-token: {token}
     - Expect 200

5. **User validation:**
   - `should return 401 if token user does not exist in database`
     - Create token for user that doesn't exist in DB
     - Expect 401, errors: 'User not found'

Implementation notes:
- The fetchUser middleware checks both 'auth-token' and 'Authorization: Bearer' headers
- Use mongoose.model('Users') to query/create users directly
- Test endpoint: POST /getcart (simpler than endpoints requiring body data)
  </action>
  <verify>
Run: `cd backend && npm test -- --run --reporter=verbose tests/integration/auth.protected.test.js`

All tests should pass. Expect 11+ test cases.
  </verify>
  <done>
auth.protected.test.js passes all tests. Protected routes correctly:
- Return 401 when no token provided
- Accept valid tokens via auth-token or Authorization: Bearer
- Reject expired tokens with 401
- Reject invalid signature tokens with 401
- Reject malformed tokens with 401
- Reject tokens for non-existent users with 401
  </done>
</task>

<task type="auto">
  <name>Task 2: Add token header format edge cases</name>
  <files>backend/tests/integration/auth.protected.test.js</files>
  <action>
Add additional edge case tests for token header parsing.

Add these test cases:

1. **Header format edge cases:**
   - `should handle Bearer with wrong case (bearer, BEARER)`
     - Test 'bearer {token}' - should work (case insensitive per spec)
     - Test 'BEARER {token}' - should work

   - `should reject Authorization header with extra spaces`
     - Set Authorization: 'Bearer  {token}' (double space)
     - May return 401 depending on parser strictness

   - `should reject Authorization header with wrong scheme`
     - Set Authorization: 'Basic {token}'
     - Expect 401

2. **Edge cases for getTokenFromRequest:**
   - `should handle both headers present (auth-token takes priority)`
     - Set both auth-token and Authorization headers with different tokens
     - Verify which one is used (auth-token should take priority per code)

These tests verify the getTokenFromRequest helper function behavior as exposed through the middleware.
  </action>
  <verify>
Run: `cd backend && npm test -- --run --reporter=verbose tests/integration/auth.protected.test.js`

All tests pass including edge cases.
  </verify>
  <done>
auth.protected.test.js has 14+ tests covering all fetchUser middleware scenarios including header format edge cases and priority handling.
  </done>
</task>

</tasks>

<verification>
```bash
cd backend && npm test -- --run --reporter=verbose tests/integration/auth.protected.test.js
```

Expected output:
- 14+ passing tests
- Valid tokens allow access
- Invalid/expired/malformed tokens return 401
- Both auth-token and Authorization: Bearer headers work
</verification>

<success_criteria>
1. auth.protected.test.js exists with 14+ passing tests
2. No token returns 401
3. Valid token returns 200
4. Expired token returns 401
5. Invalid signature returns 401
6. Malformed token string returns 401
7. Non-existent user returns 401
8. Both header formats (auth-token, Authorization: Bearer) tested
</success_criteria>

<output>
After completion, create `.planning/phases/11-authentication-a-authorization-tests/11-03-SUMMARY.md`
</output>

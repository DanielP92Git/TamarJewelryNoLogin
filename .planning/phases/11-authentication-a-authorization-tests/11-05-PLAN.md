---
phase: 11-authentication-authorization-tests
plan: 05
type: execute
wave: 3
depends_on: ["11-03", "11-04"]
files_modified:
  - backend/tests/unit/middleware/fetchUser.test.js
  - backend/tests/unit/middleware/requireAdmin.test.js
  - backend/tests/unit/middleware/authUser.test.js
autonomous: true

must_haves:
  truths:
    - "Middleware functions can be unit tested in isolation with mock req/res"
    - "fetchUser handles all token edge cases correctly"
    - "requireAdmin checks userDoc.userType exactly"
    - "authUser validates credentials with bcrypt"
  artifacts:
    - path: "backend/tests/unit/middleware/fetchUser.test.js"
      provides: "fetchUser unit tests"
      contains: "describe('fetchUser middleware'"
    - path: "backend/tests/unit/middleware/requireAdmin.test.js"
      provides: "requireAdmin unit tests"
      contains: "describe('requireAdmin middleware'"
    - path: "backend/tests/unit/middleware/authUser.test.js"
      provides: "authUser unit tests"
      contains: "describe('authUser middleware'"
  key_links:
    - from: "backend/tests/unit/middleware/*.test.js"
      to: "backend/middleware/auth.js"
      via: "direct function import and mock req/res"
      pattern: "import.*from.*middleware/auth"
---

<objective>
Create unit tests for middleware functions in isolation.

Purpose: Test middleware edge cases that are difficult to trigger via HTTP, using mock req/res objects. This provides finer-grained testing of middleware logic and faster test execution.

Output: Unit test suites for fetchUser, requireAdmin, and authUser middleware functions with comprehensive edge case coverage.
</objective>

<execution_context>
@C:\Users\pagis\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\pagis\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Phase 11 research
@.planning/phases/11-authentication-a-authorization-tests/11-RESEARCH.md

# Auth helpers
@backend/tests/helpers/authHelpers.js

# Test infrastructure
@backend/tests/setup.js
@backend/tests/helpers/factories.js

# Source code to test
@backend/middleware/auth.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create unit test directory and fetchUser tests</name>
  <files>backend/tests/unit/middleware/fetchUser.test.js</files>
  <action>
Create unit tests for fetchUser middleware using mock req/res objects.

First, create the directory structure:
```bash
mkdir -p backend/tests/unit/middleware
```

Then create the test file:

```javascript
import { describe, it, expect, vi, beforeAll, beforeEach } from 'vitest';
import jwt from 'jsonwebtoken';
import mongoose from 'mongoose';
import { fetchUser, getTokenFromRequest } from '../../../middleware/auth.js';
import { createUser } from '../../helpers/factories.js';
import { createAuthToken, createExpiredToken, TEST_JWT_KEY } from '../../helpers/authHelpers.js';

// Ensure JWT_KEY is set
process.env.JWT_KEY = TEST_JWT_KEY;

/**
 * Create mock Express request object
 */
function createMockReq(headers = {}) {
  return {
    header: vi.fn((name) => headers[name.toLowerCase()] || null),
    body: {},
    user: undefined,
    userDoc: undefined
  };
}

/**
 * Create mock Express response object
 */
function createMockRes() {
  const res = {
    statusCode: null,
    jsonData: null,
    status: vi.fn(function(code) {
      this.statusCode = code;
      return this;
    }),
    json: vi.fn(function(data) {
      this.jsonData = data;
      return this;
    })
  };
  return res;
}

/**
 * Create mock next function
 */
function createMockNext() {
  return vi.fn();
}
```

Test cases for getTokenFromRequest helper:

1. `should extract token from auth-token header`
2. `should extract token from Authorization: Bearer header`
3. `should return null when no token headers present`
4. `should prefer auth-token over Authorization header`
5. `should return null for malformed Authorization header`
6. `should handle Bearer case-insensitively`

Test cases for fetchUser middleware:

1. `should call next() for valid token with existing user`
   - Create user in DB
   - Create valid token
   - Call fetchUser(mockReq, mockRes, mockNext)
   - Expect mockNext called once
   - Expect req.user populated with id, email, userType
   - Expect req.userDoc populated with full user document

2. `should return 401 when no token provided`
   - Empty headers
   - Expect res.status(401)
   - Expect next NOT called

3. `should return 401 for expired token`
   - Use createExpiredToken
   - Expect res.status(401)

4. `should return 401 for invalid signature`
   - Sign token with wrong key
   - Expect res.status(401)

5. `should return 401 for token with missing user.id`
   - Create token with payload { user: { email: 'test' } } (no id)
   - Expect res.status(401), errors: 'Invalid token'

6. `should return 401 when user not found in database`
   - Create token for user ID that doesn't exist
   - Expect res.status(401), errors: 'User not found'

7. `should return 403 for user with invalid userType`
   - Create user with userType: 'invalid'
   - Create valid token
   - Expect res.status(403), errors: 'Forbidden'

8. `should handle jwt.verify throwing JsonWebTokenError`
   - Use completely malformed token string
   - Expect res.status(401)

Implementation notes:
- fetchUser is async, await it in tests
- Mock req.header() to return headers
- Verify both res.status() and res.json() calls
- The middleware modifies req.user and req.userDoc in place
  </action>
  <verify>
Run: `cd backend && npm test -- --run --reporter=verbose tests/unit/middleware/fetchUser.test.js`

All tests should pass. Expect 14+ test cases.
  </verify>
  <done>
fetchUser.test.js passes all tests. Unit tests verify:
- Token extraction from both header formats
- Valid token attaches user to req
- Missing token returns 401
- Expired/invalid tokens return 401
- Non-existent user returns 401
- Invalid userType returns 403
  </done>
</task>

<task type="auto">
  <name>Task 2: Create requireAdmin unit tests</name>
  <files>backend/tests/unit/middleware/requireAdmin.test.js</files>
  <action>
Create unit tests for requireAdmin middleware.

```javascript
import { describe, it, expect, vi } from 'vitest';
import { requireAdmin } from '../../../middleware/auth.js';

function createMockReq(userDoc = null) {
  return {
    userDoc: userDoc,
    user: userDoc ? { id: userDoc._id, userType: userDoc.userType } : null
  };
}

function createMockRes() {
  const res = {
    statusCode: null,
    jsonData: null,
    status: vi.fn(function(code) { this.statusCode = code; return this; }),
    json: vi.fn(function(data) { this.jsonData = data; return this; })
  };
  return res;
}
```

Test cases:

1. `should call next() for admin user`
   - req.userDoc = { userType: 'admin' }
   - Expect next() called
   - Expect res.status NOT called

2. `should return 403 for regular user`
   - req.userDoc = { userType: 'user' }
   - Expect res.status(403)
   - Expect res.json includes 'Admin access required'

3. `should return 403 when req.userDoc is undefined`
   - req.userDoc = undefined
   - Expect res.status(403)

4. `should return 403 when req.userDoc is null`
   - req.userDoc = null
   - Expect res.status(403)

5. `should return 403 for userType: 'Admin' (case sensitive)`
   - req.userDoc = { userType: 'Admin' }
   - Expect res.status(403)

6. `should return 403 for userType: 'administrator'`
   - req.userDoc = { userType: 'administrator' }
   - Expect res.status(403)

7. `should return 403 for empty userType`
   - req.userDoc = { userType: '' }
   - Expect res.status(403)

8. `should include success: false in 403 response`
   - Verify response body includes success: false

Note: requireAdmin is synchronous (not async), no await needed.
  </action>
  <verify>
Run: `cd backend && npm test -- --run --reporter=verbose tests/unit/middleware/requireAdmin.test.js`

All tests should pass. Expect 8+ test cases.
  </verify>
  <done>
requireAdmin.test.js passes all tests. Unit tests verify:
- Admin users pass through
- Non-admin users get 403
- Null/undefined userDoc gets 403
- userType checking is case-sensitive
- Response includes proper error message
  </done>
</task>

<task type="auto">
  <name>Task 3: Create authUser unit tests</name>
  <files>backend/tests/unit/middleware/authUser.test.js</files>
  <action>
Create unit tests for authUser middleware (handles login validation).

Note: authUser is more complex because it uses bcrypt with callbacks and queries the database. Tests need to handle the async callback pattern.

```javascript
import { describe, it, expect, vi, beforeEach } from 'vitest';
import mongoose from 'mongoose';
import { authUser } from '../../../middleware/auth.js';
import { createUser } from '../../helpers/factories.js';
import bcrypt from 'bcrypt';

function createMockReq(body = {}) {
  return {
    body: body,
    user: undefined
  };
}

function createMockRes() {
  const res = {
    statusCode: null,
    jsonData: null,
    status: vi.fn(function(code) { this.statusCode = code; return this; }),
    json: vi.fn(function(data) { this.jsonData = data; return this; })
  };
  return res;
}
```

Test cases:

1. `should call next() and attach user for valid credentials`
   - Create user in DB with hashed password
   - req.body = { email, password: 'plaintext' }
   - await authUser(req, res, next)
   - Expect next() called
   - Expect req.user to be the user document

2. `should return 401 for incorrect password`
   - Create user with known password
   - req.body.password = 'wrongpassword'
   - Expect res.status(401)
   - Expect errors: 'Auth Failed'

3. `should return 404 for non-existent email`
   - req.body.email = 'nonexistent@example.com'
   - Expect res.status(404)
   - Expect errors contains 'No user found'

4. `should return 500 for database error`
   - This is harder to test - may skip or use vi.spyOn

5. `should handle bcrypt comparison errors`
   - Edge case: bcrypt.compare returns error
   - Expect 401

6. `should reject user with invalid userType`
   - Create user with userType: 'guest' (not user/admin)
   - Expect error (code throws for invalid userType)

7. `should authenticate admin user with admin userType`
   - Create admin user
   - Authenticate with correct password
   - Expect next() called
   - Expect req.user.userType === 'admin'

Note: authUser uses callback-based bcrypt.compare, so the function returns before the callback completes. Tests may need to use a longer timeout or check the response after a delay.

Implementation approach:
- Create user with bcrypt.hashSync (synchronous)
- Call authUser and await it (it's marked async)
- The bcrypt.compare callback should complete before promise resolves
- If tests are flaky, add small delay or use vi.waitFor()
  </action>
  <verify>
Run: `cd backend && npm test -- --run --reporter=verbose tests/unit/middleware/authUser.test.js`

All tests should pass. Expect 6+ test cases.
  </verify>
  <done>
authUser.test.js passes all tests. Unit tests verify:
- Valid credentials authenticate and attach user
- Invalid password returns 401
- Non-existent email returns 404
- Invalid userType throws error
- bcrypt comparison errors return 401
  </done>
</task>

</tasks>

<verification>
```bash
cd backend && npm test -- --run --reporter=verbose tests/unit/middleware/
```

Expected output:
- 28+ passing tests across all middleware unit tests
- fetchUser, requireAdmin, and authUser all tested in isolation
- Mock req/res pattern working correctly
</verification>

<success_criteria>
1. backend/tests/unit/middleware/ directory exists with 3 test files
2. fetchUser.test.js has 14+ passing tests
3. requireAdmin.test.js has 8+ passing tests
4. authUser.test.js has 6+ passing tests
5. All middleware functions tested with mock req/res objects
6. Edge cases covered (null, undefined, empty string, wrong types)
7. Error responses verified (status codes, error messages)
</success_criteria>

<output>
After completion, create `.planning/phases/11-authentication-a-authorization-tests/11-05-SUMMARY.md`
</output>

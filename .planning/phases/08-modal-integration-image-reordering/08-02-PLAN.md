---
phase: 08-modal-integration-image-reordering
plan: 02
type: execute
wave: 2
depends_on: ["08-01"]
files_modified:
  - admin/BisliView.js
autonomous: true

must_haves:
  truths:
    - "Modal includes Edit button that navigates to edit page"
    - "Modal includes Delete button that deletes product with confirmation"
    - "Modal includes Duplicate button that duplicates product"
    - "Focus returns to product row after modal closes"
  artifacts:
    - path: "admin/BisliView.js"
      provides: "Modal action button handlers"
      contains: "data-action=\"edit\""
  key_links:
    - from: "Edit button"
      to: "editProduct function"
      via: "click handler"
      pattern: "editProduct\\(product\\)"
    - from: "Delete button"
      to: "removeproduct API"
      via: "fetch POST"
      pattern: "removeproduct"
    - from: "Duplicate button"
      to: "openDuplicateProduct function"
      via: "click handler"
      pattern: "openDuplicateProduct"
---

<objective>
Wire modal action buttons (Edit, Delete, Duplicate) to their existing functionality.

Purpose: Allow admin to take quick actions from the preview modal without navigating back to product list. This matches UX patterns from Shopify/WooCommerce where preview modals include action shortcuts.

Output: Modal footer buttons are functional - Edit navigates to edit form, Delete removes product with confirmation, Duplicate opens duplicate form.
</objective>

<execution_context>
@C:\Users\pagis\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\pagis\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/STATE.md
@.planning/phases/08-modal-integration-image-reordering/08-01-SUMMARY.md

# Existing action implementations to reuse
@admin/BisliView.js (editProduct at ~line 2543, delete handler at ~line 2311, openDuplicateProduct for duplicate)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Wire Edit button to navigate to edit page</name>
  <files>admin/BisliView.js</files>
  <action>
In the `openProductPreview` function (created in Plan 01), add Edit button handler:

1. Locate the modal footer HTML in openProductPreview where buttons are defined:
   ```javascript
   <footer class="modal-footer">
     <button type="button" class="btn" data-action="duplicate">Duplicate</button>
     <button type="button" class="btn btn--danger" data-action="delete">Delete</button>
     <button type="button" class="btn btn--primary" data-action="edit">Edit</button>
   </footer>
   ```

2. Add click handler for Edit button after dialog.showModal():
   ```javascript
   dialog.querySelector('[data-action="edit"]').addEventListener('click', () => {
     dialog.close();
     editProduct(product);
   });
   ```

3. Ensure editProduct function is accessible in scope. It's already defined globally in BisliView.js, so no imports needed.

The Edit button should:
- Close the modal first (so focus management works correctly)
- Call existing editProduct(product) which navigates to the edit form
- editProduct already handles setActiveNav("edit-product") and renders the form
  </action>
  <verify>
```bash
grep -n "data-action=\"edit\"" admin/BisliView.js
grep -A2 "data-action=\"edit\"" admin/BisliView.js | grep -i "editProduct"
```
  </verify>
  <done>
Edit button click closes modal and calls editProduct(product), navigating admin to the product edit form.
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire Delete button with confirmation dialog</name>
  <files>admin/BisliView.js</files>
  <action>
Add Delete button handler in openProductPreview after the Edit handler:

```javascript
dialog.querySelector('[data-action="delete"]').addEventListener('click', async () => {
  // Use native confirm for simplicity (consistent with existing delete pattern)
  if (!confirm(`Delete "${product.name}"? This cannot be undone.`)) {
    return;
  }

  dialog.close();

  try {
    const response = await fetch(`${API_URL}/removeproduct`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${localStorage.getItem('auth-token')}`
      },
      body: JSON.stringify({ id: product._id })
    });

    const result = await response.json();
    if (result.success) {
      showSuccessToast('Product deleted successfully');
      fetchInfo(); // Refresh the product list
    } else {
      throw new Error(result.message || 'Failed to delete product');
    }
  } catch (error) {
    console.error('Error deleting product:', error);
    showErrorToast('Error deleting product: ' + error.message);
  }
});
```

This mirrors the existing delete handler at line ~2311 but:
- Uses showSuccessToast/showErrorToast instead of alert() for better UX
- Closes modal first before making API call
- Refreshes product list on success
  </action>
  <verify>
```bash
grep -n "data-action=\"delete\"" admin/BisliView.js
grep -B2 -A10 "data-action=\"delete\"" admin/BisliView.js | grep "removeproduct"
```
  </verify>
  <done>
Delete button shows confirmation, calls /removeproduct API, shows toast feedback, and refreshes product list on success.
  </done>
</task>

<task type="auto">
  <name>Task 3: Wire Duplicate button to open duplicate form</name>
  <files>admin/BisliView.js</files>
  <action>
Add Duplicate button handler in openProductPreview after the Delete handler:

```javascript
dialog.querySelector('[data-action="duplicate"]').addEventListener('click', async () => {
  dialog.close();

  try {
    // Fetch full product data (modal may have partial data)
    const fullProduct = await fetchProduct(product._id);
    await openDuplicateProduct(fullProduct);
  } catch (error) {
    console.error('Error duplicating product:', error);
    showErrorToast('Error duplicating product: ' + (error.message || 'Unknown error'));
  }
});
```

This mirrors the existing duplicate handler at line ~2353:
- Uses fetchProduct to get complete product data
- Calls existing openDuplicateProduct function
- Shows error toast on failure

Note: fetchProduct and openDuplicateProduct are already defined in BisliView.js. Verify they exist:
- fetchProduct should be around line 400-500 (fetches single product by ID)
- openDuplicateProduct should be around line 3700+ (opens add product form with pre-filled data)
  </action>
  <verify>
```bash
grep -n "data-action=\"duplicate\"" admin/BisliView.js
grep -n "function fetchProduct" admin/BisliView.js
grep -n "function openDuplicateProduct" admin/BisliView.js
```
  </verify>
  <done>
Duplicate button fetches full product data and calls openDuplicateProduct to open pre-filled add product form.
  </done>
</task>

</tasks>

<verification>
After all tasks complete:

1. Code validation:
```bash
# All three action buttons wired
grep -c "data-action=" admin/BisliView.js
# Should show at least 3 for edit, delete, duplicate

# Each action has its handler
grep -n "addEventListener.*click" admin/BisliView.js | grep -E "edit|delete|duplicate" | wc -l
```

2. Functional test (manual):
   - Open product preview modal
   - Click Edit button -> should navigate to edit form for that product
   - Go back to list, open preview for another product
   - Click Duplicate button -> should open add product form with data pre-filled
   - Go back to list, open preview for a test product
   - Click Delete button -> should show confirmation
   - Cancel confirmation -> modal should stay open (or reopen)
   - Confirm deletion -> product should be deleted, list refreshed, toast shown
</verification>

<success_criteria>
- [ ] Edit button closes modal and navigates to edit form (MODAL-03)
- [ ] Delete button shows confirmation before deleting (MODAL-09)
- [ ] Duplicate button opens duplicate form with product data (MODAL-09)
- [ ] All actions use existing functions (editProduct, openDuplicateProduct, removeproduct API)
- [ ] Toast notifications shown for success/error feedback
- [ ] Product list refreshes after delete
</success_criteria>

<output>
After completion, create `.planning/phases/08-modal-integration-image-reordering/08-02-SUMMARY.md`
</output>

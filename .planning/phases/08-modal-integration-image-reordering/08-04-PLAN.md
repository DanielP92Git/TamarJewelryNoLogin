---
phase: 08-modal-integration-image-reordering
plan: 04
type: execute
wave: 2
depends_on: ["08-03"]
files_modified:
  - admin/BisliView.js
  - backend/index.js
autonomous: true

must_haves:
  truths:
    - "Image order changes persist when product form is submitted"
    - "Admin can delete image from gallery with confirmation dialog"
    - "Deleted image is removed from gallery and database"
    - "Backend accepts and processes imageOrder in update request"
  artifacts:
    - path: "admin/BisliView.js"
      provides: "Image delete handlers, form submit with image order"
      contains: "imageOrder"
    - path: "backend/index.js"
      provides: "Update endpoint handles images array reordering"
      contains: "imageOrder"
  key_links:
    - from: "admin/BisliView.js form submit"
      to: "backend /updateproduct/:id"
      via: "FormData with imageOrder"
      pattern: "imageOrder"
    - from: "backend /updateproduct/:id"
      to: "product.images array"
      via: "reorder based on imageOrder"
      pattern: "images.*sort|reorder"
---

<objective>
Complete image gallery management: persist order changes on form submit and enable image deletion.

Purpose: Admin's image order changes must actually save to the database when the product form is submitted. Additionally, admin should be able to remove unwanted images from the gallery.

Output: Product update saves reordered images array, delete buttons remove images with confirmation, changes persist in database.
</objective>

<execution_context>
@C:\Users\pagis\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\pagis\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/STATE.md
@.planning/phases/08-modal-integration-image-reordering/08-03-SUMMARY.md

# Existing update endpoint and delete patterns
@backend/index.js (updateproduct endpoint, deleteproductimage endpoint)
@admin/BisliView.js (form submit handler in editProduct, existing deleteProductImage calls)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Update backend to handle image order in product updates</name>
  <files>backend/index.js</files>
  <action>
Find the `/updateproduct/:id` endpoint in backend/index.js and modify it to handle image reordering:

1. Locate the updateproduct endpoint (search for `app.put('/updateproduct/:id'` or similar).

2. In the request body parsing, add imageOrder handling:

```javascript
// After extracting other fields from req.body
const { imageOrder } = req.body;

// If imageOrder is provided, reorder the images array
if (imageOrder) {
  try {
    const orderArray = typeof imageOrder === 'string' ? JSON.parse(imageOrder) : imageOrder;

    if (Array.isArray(orderArray) && orderArray.length > 0) {
      // Get current images from product
      const currentImages = product.images || [];

      // Create a map for quick lookup by URL
      const imageMap = new Map();
      currentImages.forEach(img => {
        const key = img.desktop || img.publicDesktop || img.desktopLocal || '';
        if (key) imageMap.set(key, img);
      });

      // Reorder images based on orderArray
      const reorderedImages = [];
      orderArray.forEach(url => {
        const decodedUrl = decodeURIComponent(url);
        if (imageMap.has(decodedUrl)) {
          reorderedImages.push(imageMap.get(decodedUrl));
          imageMap.delete(decodedUrl); // Mark as used
        }
      });

      // Append any images not in orderArray (shouldn't happen, but defensive)
      imageMap.forEach(img => reorderedImages.push(img));

      // Update product images array
      product.images = reorderedImages;

      // Update derived fields for backwards compatibility
      if (reorderedImages.length > 0) {
        product.mainImage = reorderedImages[0];
      }
      if (reorderedImages.length > 1) {
        product.smallImages = reorderedImages.slice(1);
      }

      console.log('[updateproduct] Reordered images:', {
        productId: product._id,
        newOrder: reorderedImages.map(img => img.desktop || img.publicDesktop).slice(0, 3)
      });
    }
  } catch (err) {
    console.error('[updateproduct] Error parsing imageOrder:', err);
    // Continue without reordering on parse error
  }
}
```

3. Ensure the product is saved with the updated images array (should be handled by existing save logic).

4. Test that the endpoint accepts imageOrder in both JSON body and FormData (if using multipart).
  </action>
  <verify>
```bash
grep -n "imageOrder" backend/index.js
grep -n "reorderedImages\|reorderImages" backend/index.js
```
  </verify>
  <done>
Backend /updateproduct/:id endpoint parses imageOrder from request, reorders product.images array, updates derived fields (mainImage, smallImages), and saves to database.
  </done>
</task>

<task type="auto">
  <name>Task 2: Update frontend form submit to include image order</name>
  <files>admin/BisliView.js</files>
  <action>
Find the form submit handler in editProduct function and include imageOrder in the update request:

1. Locate the form submit handler in editProduct (search for `form.addEventListener('submit'` or similar, around line 3000+).

2. Before making the fetch/update request, get the current image order:

```javascript
// Get image order from hidden field
const imageOrderInput = document.getElementById('imageOrderInput');
const imageOrder = imageOrderInput ? imageOrderInput.value : null;
```

3. If using FormData:
```javascript
if (imageOrder) {
  formData.append('imageOrder', imageOrder);
}
```

4. If using JSON body:
```javascript
const updateData = {
  // ... existing fields ...
  imageOrder: imageOrder ? JSON.parse(imageOrder) : undefined
};
```

5. The form submit should already be calling `/updateproduct/:id` - just ensure imageOrder is included in the payload.

6. Add a success indicator that image order was updated (optional toast):
```javascript
// On successful save
if (imageOrder) {
  console.log('[editProduct] Image order saved');
}
```
  </action>
  <verify>
```bash
grep -n "imageOrderInput" admin/BisliView.js
grep -B5 -A5 "updateproduct" admin/BisliView.js | grep -i "imageOrder\|formData"
```
  </verify>
  <done>
Form submit handler includes imageOrder field in update request payload, sending reordered image URLs to backend.
  </done>
</task>

<task type="auto">
  <name>Task 3: Implement image delete functionality</name>
  <files>admin/BisliView.js</files>
  <action>
Add image delete handlers in the setupEditFormImageGallery function (or as a separate function called from there):

1. Add setupImageDeleteButtons function after setupEditFormImageGallery:

```javascript
/**
 * Setup delete button handlers for gallery images
 * @param {HTMLElement} container - Gallery container
 * @param {string} productId - Product MongoDB _id
 */
function setupImageDeleteButtons(container, productId) {
  container.querySelectorAll('.delete-image-btn').forEach(btn => {
    btn.addEventListener('click', async (e) => {
      e.preventDefault();
      e.stopPropagation();

      const imageUrl = decodeURIComponent(btn.dataset.url);
      const imageIndex = parseInt(btn.dataset.index, 10);
      const thumb = btn.closest('.gallery-thumb');

      // Confirmation dialog (IMAGE-08)
      if (!confirm('Delete this image from the gallery?')) {
        return;
      }

      btn.disabled = true;

      try {
        const response = await fetch(`${API_URL}/deleteproductimage`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${localStorage.getItem('auth-token')}`
          },
          body: JSON.stringify({
            productId,
            imageUrl,
            imageIndex
          })
        });

        const result = await response.json();

        if (response.ok && result.success) {
          // Remove thumbnail from DOM
          thumb.remove();

          // Update main badge on new first image
          updateMainImageBadge(container);

          // Update hidden order field
          updateImageOrderField(container);

          showSuccessToast('Image deleted');

          // Check if gallery is now empty
          if (container.querySelectorAll('.gallery-thumb').length === 0) {
            container.innerHTML = '<p class="gallery-help-text">No images remaining</p>';
          }
        } else {
          throw new Error(result.message || 'Failed to delete image');
        }
      } catch (error) {
        console.error('[deleteImage] Error:', error);
        showErrorToast('Failed to delete image: ' + error.message);
        btn.disabled = false;
      }
    });
  });
}
```

2. Call setupImageDeleteButtons in setupEditFormImageGallery, after the SortableJS initialization:

```javascript
// At end of setupEditFormImageGallery, after Sortable.create
setupImageDeleteButtons(container, product._id);
```

3. Verify the backend /deleteproductimage endpoint exists and handles both legacy and images array formats. Check backend/index.js for this endpoint.
  </action>
  <verify>
```bash
grep -n "function setupImageDeleteButtons" admin/BisliView.js
grep -n "deleteproductimage" admin/BisliView.js
grep -n "deleteproductimage" backend/index.js
```
  </verify>
  <done>
Delete buttons on gallery thumbnails show confirmation, call /deleteproductimage API, remove thumbnail from DOM, update main badge, and show toast feedback.
  </done>
</task>

</tasks>

<verification>
After all tasks complete:

1. Backend validation:
```bash
grep -n "imageOrder" backend/index.js
# Should show imageOrder handling in updateproduct endpoint
```

2. Frontend validation:
```bash
grep -n "imageOrder" admin/BisliView.js
# Should show multiple occurrences (hidden input, form submit, order field)

grep -n "setupImageDeleteButtons" admin/BisliView.js
# Should show function definition and call
```

3. Functional test (manual):
   - Edit a product with multiple images
   - Reorder images by dragging
   - Click Save - verify no errors
   - Reload the page and edit same product - images should be in new order
   - Try deleting an image:
     - Click delete button (X) on a thumbnail
     - Confirm the dialog
     - Image should disappear from gallery
     - Save the product
     - Reload and verify image is gone
   - Test deleting the main (first) image - next image should become main
</verification>

<success_criteria>
- [ ] Image order persists when form is submitted (IMAGE-06)
- [ ] Backend reorders images array based on imageOrder parameter
- [ ] Derived fields (mainImage, smallImages) updated for backwards compatibility
- [ ] Delete button shows confirmation dialog (IMAGE-08)
- [ ] Deleted image removed from DOM and database
- [ ] Main badge moves to new first image after delete
- [ ] Toast notifications for success/error feedback
- [ ] Form dirty state tracked when order changes
</success_criteria>

<output>
After completion, create `.planning/phases/08-modal-integration-image-reordering/08-04-SUMMARY.md`
</output>

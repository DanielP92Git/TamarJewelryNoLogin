---
phase: 18-model-unit-tests
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - frontend/tests/helpers/mocks/fetch.js
  - frontend/tests/helpers/mocks/dom-elements.js
  - frontend/tests/model/cart.test.js
autonomous: true

must_haves:
  truths:
    - "Cart add operation adds product with correct quantity and price"
    - "Cart remove operation removes product from cart state"
    - "Cart update operation changes product quantity"
    - "Cart clear operation removes all items from cart"
    - "Both guest and logged-in code paths are tested"
  artifacts:
    - path: "frontend/tests/helpers/mocks/fetch.js"
      provides: "Fetch mock utilities for API testing"
      exports: ["setupFetchMock", "teardownFetchMock", "mockFetchSuccess", "mockFetchError", "mockFetchNetworkError"]
    - path: "frontend/tests/helpers/mocks/dom-elements.js"
      provides: "DOM element mocks for addToLocalStorage"
      exports: ["createMockProductElement"]
    - path: "frontend/tests/model/cart.test.js"
      provides: "Cart operation tests"
      min_lines: 80
  key_links:
    - from: "frontend/tests/model/cart.test.js"
      to: "frontend/js/model.js"
      via: "import cart, handleAddToCart, removeFromUserCart, deleteAll"
      pattern: "import.*from.*model\\.js"
    - from: "frontend/tests/model/cart.test.js"
      to: "frontend/tests/helpers/mocks/dom-elements.js"
      via: "createMockProductElement for test DOM elements"
      pattern: "createMockProductElement"
---

<objective>
Create cart operation tests covering add, remove, update, and clear operations for both guest and logged-in user paths.

Purpose: Validate that cart state mutations work correctly and persist to localStorage (guest) or trigger API calls (logged-in). This establishes the foundational test mocks (fetch, DOM elements) used by subsequent plans.

Output: Fetch mock utilities, DOM element mock helper, and comprehensive cart.test.js with tests for MODEL-01 through MODEL-04.
</objective>

<execution_context>
@C:\Users\pagis\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\pagis\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/18-model-unit-tests/18-CONTEXT.md
@.planning/phases/18-model-unit-tests/18-RESEARCH.md
@.planning/phases/17-test-infrastructure-utilities/17-03-SUMMARY.md
@frontend/js/model.js
@frontend/tests/setup.js
@frontend/tests/helpers/factories.js
@frontend/tests/helpers/dom.js
@frontend/vitest.config.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create fetch mock utilities</name>
  <files>frontend/tests/helpers/mocks/fetch.js</files>
  <action>
Create fetch mock utilities following the pattern from 18-RESEARCH.md:

1. Create `frontend/tests/helpers/mocks/` directory if it doesn't exist
2. Create `fetch.js` with these exports:
   - `setupFetchMock()` - Saves original fetch and replaces with vi.fn()
   - `teardownFetchMock()` - Restores original fetch
   - `mockFetchSuccess(data)` - Mocks successful JSON response
   - `mockFetchError(statusCode, message)` - Mocks HTTP error response
   - `mockFetchNetworkError()` - Mocks network failure (TypeError)

Pattern from research:
```javascript
import { vi } from 'vitest';

let originalFetch;

export function setupFetchMock() {
  originalFetch = global.fetch;
  global.fetch = vi.fn();
}

export function teardownFetchMock() {
  global.fetch = originalFetch;
}

export function mockFetchSuccess(data) {
  global.fetch.mockResolvedValueOnce({
    ok: true,
    json: async () => data
  });
}

export function mockFetchError(statusCode, message = 'Error') {
  global.fetch.mockResolvedValueOnce({
    ok: false,
    status: statusCode,
    json: async () => ({ error: message })
  });
}

export function mockFetchNetworkError() {
  global.fetch.mockRejectedValueOnce(new TypeError('Failed to fetch'));
}
```
  </action>
  <verify>File exists at frontend/tests/helpers/mocks/fetch.js with all 5 exported functions</verify>
  <done>Fetch mock utilities are available for import in test files</done>
</task>

<task type="auto">
  <name>Task 2: Create DOM element mock helper</name>
  <files>frontend/tests/helpers/mocks/dom-elements.js</files>
  <action>
Create DOM element mock helper for addToLocalStorage testing:

The model.js addToLocalStorage function reads from:
- data-id attribute
- data-quant attribute
- data-currency attribute
- data-usd-price, data-ils-price attributes
- data-original-usd-price, data-original-ils-price attributes
- .front-image child element (src attribute)
- .item-title child element (textContent)
- .item-price-discounted child element (presence indicates discount)

Create `createMockProductElement(product, options = {})` that:
1. Creates a div element with proper data-* attributes from product
2. Adds required child elements (.front-image, .item-title)
3. Optionally adds .item-price-discounted if options.hasDiscount is true
4. Returns the element for use with handleAddToCart/addToLocalStorage

Pattern from research:
```javascript
export function createMockProductElement(product, options = {}) {
  const element = document.createElement('div');
  element.setAttribute('data-id', product.id);
  element.setAttribute('data-quant', product.quantity || 10);
  element.setAttribute('data-currency', options.currency || 'ils');
  element.setAttribute('data-usd-price', product.usd_price || 50);
  element.setAttribute('data-ils-price', product.ils_price || 185);
  element.setAttribute('data-original-usd-price', product.usd_price || 50);
  element.setAttribute('data-original-ils-price', product.ils_price || 185);

  // Required child elements
  const img = document.createElement('img');
  img.className = 'front-image';
  img.src = product.images?.[0]?.desktop || 'test.jpg';
  element.appendChild(img);

  const title = document.createElement('span');
  title.className = 'item-title';
  title.textContent = product.name;
  element.appendChild(title);

  // Optional discount price element
  if (options.hasDiscount) {
    const discountPrice = document.createElement('span');
    discountPrice.className = 'item-price-discounted';
    element.appendChild(discountPrice);
  }

  return element;
}
```
  </action>
  <verify>File exists at frontend/tests/helpers/mocks/dom-elements.js with createMockProductElement export</verify>
  <done>DOM element mock helper is available for cart operation tests</done>
</task>

<task type="auto">
  <name>Task 3: Create cart operation tests</name>
  <files>frontend/tests/model/cart.test.js</files>
  <action>
Create comprehensive cart operation tests covering MODEL-01 through MODEL-04:

1. Create `frontend/tests/model/` directory if it doesn't exist
2. Create `cart.test.js` with describe blocks for:

**Setup pattern (CRITICAL - from research pitfalls):**
```javascript
import { cart, handleAddToCart, removeFromUserCart, deleteAll } from '../../js/model.js';

beforeEach(() => {
  cart.length = 0;  // MUST clear exported cart array
  localStorage.clear();
  resetFactoryCounter();
});
```

**Test structure:**

a) `describe('Add to Cart - Guest User')` (MODEL-01)
   - Should add product to cart array with correct properties
   - Should store both USD and ILS prices
   - Should set amount to 1 for new items
   - Should persist to localStorage
   - Should NOT call fetch (guest path)

b) `describe('Add to Cart - Logged-in User')` (MODEL-01 logged-in path)
   - Set localStorage.setItem('auth-token', 'mock-token') in beforeEach
   - Should call /addtocart API with correct headers and body
   - Should include auth-token header

c) `describe('Remove from Cart - Guest User')` (MODEL-02)
   - Should remove item by ID from cart array
   - Should update localStorage after removal
   - Should handle removing non-existent item gracefully

d) `describe('Remove from Cart - Logged-in User')` (MODEL-02 logged-in path)
   - Should call /removefromcart API
   - Should remove from cart array AND call API

e) `describe('Cart Clear - Guest User')` (MODEL-04)
   - Should empty cart array
   - Should update localStorage to empty array

f) `describe('Cart Clear - Logged-in User')` (MODEL-04 logged-in path)
   - Should call /removeAll API

Note on MODEL-03 (update quantity): Review model.js - if there's no explicit update quantity function, document this as "behavior tested via add/remove patterns" since adding same product twice appears to create duplicates rather than updating quantity (from research open questions).

**Import pattern:**
```javascript
import { describe, it, expect, beforeEach, afterEach, vi } from 'vitest';
import { cart, handleAddToCart, removeFromUserCart, deleteAll } from '../../js/model.js';
import { createProduct, resetFactoryCounter } from '../helpers/factories.js';
import { createMockProductElement } from '../helpers/mocks/dom-elements.js';
import { setupFetchMock, teardownFetchMock, mockFetchSuccess } from '../helpers/mocks/fetch.js';
```

Target: At least 10 tests covering both guest and logged-in paths for add/remove/clear.
  </action>
  <verify>Run `npm test -- --run tests/model/cart.test.js` from frontend directory - all tests pass</verify>
  <done>Cart operation tests validate add/remove/clear for both guest and logged-in users (MODEL-01, MODEL-02, MODEL-04)</done>
</task>

</tasks>

<verification>
1. All test files exist in correct locations
2. `npm test -- --run tests/model/cart.test.js` passes all tests
3. Tests cover both guest (no auth-token) and logged-in (with auth-token) paths
4. Cart array is properly cleared between tests (no test pollution)
5. Fetch mock captures API calls for logged-in path verification
</verification>

<success_criteria>
- Fetch mock utilities available at frontend/tests/helpers/mocks/fetch.js
- DOM element mock available at frontend/tests/helpers/mocks/dom-elements.js
- Cart tests pass for add, remove, and clear operations
- Both guest and logged-in code paths have test coverage
- Requirements MODEL-01, MODEL-02, MODEL-04 addressed (MODEL-03 may need documentation if no explicit update function exists)
</success_criteria>

<output>
After completion, create `.planning/phases/18-model-unit-tests/18-01-SUMMARY.md`
</output>

---
phase: 21-locale-currency-tests
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - frontend/tests/locale/hydration.test.js
  - frontend/tests/locale/bidi.test.js
autonomous: true

must_haves:
  truths:
    - "hydrateLocaleFromBackend skips fetch when user already had language and currency preferences"
    - "hydrateLocaleFromBackend fetches /api/locale and updates localStorage with GeoIP result"
    - "hydrateLocaleFromBackend falls back to /locale when /api/locale fails"
    - "hydrateLocaleFromBackend dispatches currency-changed CustomEvent when currency is overridden"
    - "hydrateLocaleFromBackend only overrides auto-filled values, not user-chosen preferences"
    - "hydrateLocaleFromBackend handles fetch timeout gracefully (900ms AbortController)"
    - "hydrateLocaleFromBackend handles complete network failure without crashing"
    - "hydrateLocaleFromBackend resets __localeAuto flags after completion"
    - "SKU elements in product cards have dir='ltr' attribute for bidirectional text correctness"
  artifacts:
    - path: "frontend/tests/locale/hydration.test.js"
      provides: "Tests for hydrateLocaleFromBackend GeoIP fetch, fallback chain, and preference respect"
      min_lines: 120
    - path: "frontend/tests/locale/bidi.test.js"
      provides: "Tests for bidirectional text handling in Hebrew mode (SKU dir=ltr)"
      min_lines: 40
  key_links:
    - from: "frontend/tests/locale/hydration.test.js"
      to: "frontend/js/locale.js"
      via: "import { hydrateLocaleFromBackend } from locale.js"
      pattern: "hydrateLocaleFromBackend"
    - from: "frontend/tests/locale/hydration.test.js"
      to: "window.__localeAuto"
      via: "__localeAuto flags control hydration behavior"
      pattern: "__localeAuto"
    - from: "frontend/tests/locale/bidi.test.js"
      to: "frontend/js/Views/categoriesView.js"
      via: "CategoriesView.buildSkuBadge generates SKU markup with dir=ltr"
      pattern: "dir=\"ltr\"|sku-value"
---

<objective>
Test hydrateLocaleFromBackend() GeoIP detection and fallback chain, plus bidirectional text handling.

Purpose: Verify LOCALE-11 (GeoIP detection from backend), LOCALE-12 (fallback chain when detection fails), and LOCALE-10 (bidirectional text with Hebrew names and English SKUs). These are the async locale functions and the one integration point for bidi text.

Output: `frontend/tests/locale/hydration.test.js` and `frontend/tests/locale/bidi.test.js`
</objective>

<execution_context>
@C:\Users\pagis\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\pagis\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/21-locale-currency-tests/21-RESEARCH.md
@.planning/phases/21-locale-currency-tests/21-CONTEXT.md
@frontend/js/locale.js
@frontend/js/Views/categoriesView.js
@frontend/tests/setup.js
@frontend/tests/helpers/dom.js
@frontend/tests/helpers/factories.js
@frontend/vitest.config.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create hydration and GeoIP tests</name>
  <files>frontend/tests/locale/hydration.test.js</files>
  <action>
Create `frontend/tests/locale/hydration.test.js` test file.

This file tests hydrateLocaleFromBackend() â€” the async function that fetches GeoIP data from the backend and conditionally overrides locale. This is the core of LOCALE-11 and LOCALE-12.

**Key insight from locale.js code:** hydrateLocaleFromBackend() checks window.__localeAuto flags to decide whether to fetch. If both langWasMissing and currencyWasMissing are false, it returns early without fetching.

**Setup requirements:**
- Mock global.fetch with vi.fn()
- Mock window.location.origin for getApiBase() (use Object.defineProperty or vi.stubGlobal)
- Set window.__localeAuto flags before each test to control hydration behavior
- Clean up __localeAuto in afterEach
- Mock AbortController for timeout tests (or use vi.useFakeTimers)

**Fetch mock helper pattern:**
```javascript
function mockFetchResponse(data) {
  return vi.fn(() => Promise.resolve({
    ok: true,
    json: () => Promise.resolve(data)
  }));
}

function mockFetchError(error) {
  return vi.fn(() => Promise.reject(error));
}

function mockFetchSequence(...responses) {
  const fn = vi.fn();
  responses.forEach((resp, i) => {
    fn.mockImplementationOnce(resp);
  });
  return fn;
}
```

Test cases for hydration.test.js (~18-22 tests):

**Early return (user has preferences):**
- When __localeAuto is undefined: skips fetch, no network call made
- When __localeAuto = { langWasMissing: false, currencyWasMissing: false }: skips fetch
- Verify fetch is NOT called (expect(fetch).not.toHaveBeenCalled())

**LOCALE-11 - Successful GeoIP detection:**
- __localeAuto = { langWasMissing: true, currencyWasMissing: true }
- Fetch returns { ok: true, country: "IL", appLang: "heb", appCurrency: "ils" }
- After hydration: localStorage language = 'heb', currency = 'ils'
- After hydration: document.documentElement.lang = 'he', dir = 'rtl'
- After hydration: currency-changed event dispatched with { currency: 'ils' }

**GeoIP with only language missing:**
- __localeAuto = { langWasMissing: true, currencyWasMissing: false }
- Fetch returns Israeli locale
- Language updated, currency NOT changed (already had user preference)
- currency-changed event NOT dispatched

**GeoIP with only currency missing:**
- __localeAuto = { langWasMissing: false, currencyWasMissing: true }
- Fetch returns Israeli locale
- Currency updated, language NOT changed
- currency-changed event IS dispatched (currency changed)

**LOCALE-12 - Fallback chain:**
- Primary /api/locale fails (non-ok response), fallback /locale succeeds
- Verify first fetch call URL contains '/api/locale'
- Verify second fetch call URL contains '/locale'
- Locale correctly applied from fallback response

**LOCALE-12 - Complete failure:**
- Both /api/locale and /locale fail (network error)
- No crash, localStorage retains previous values (browser guess from bootstrap)
- __localeAuto reset to { langWasMissing: false, currencyWasMissing: false }

**Timeout behavior (900ms):**
- Use vi.useFakeTimers() for this test group
- Set up fetch that never resolves
- Advance timers past 900ms to trigger AbortController.abort()
- Verify hydration completes without crash
- Verify __localeAuto flags are reset in finally block

**Backend response variations:**
- Response with ISO codes only (no appLang/appCurrency): mapIsoToApp handles mapping
  - { ok: true, lang: "he", currency: "ILS" } -> appLang: "heb", appCurrency: "ils"
- Response with ok: false: treated as failure, no locale update
- Response with null/undefined payload: treated as failure

**__localeAuto flag reset:**
- After successful hydration: __localeAuto = { langWasMissing: false, currencyWasMissing: false }
- After failed hydration: __localeAuto = { langWasMissing: false, currencyWasMissing: false }
- This prevents repeated override attempts on navigation within same page load

**Currency-changed event verification:**
Use window.addEventListener('currency-changed', spy) to capture dispatched events. Clean up listener in afterEach.

**Comment at top of file:**
```javascript
/**
 * hydrateLocaleFromBackend() tests.
 *
 * Verifies async GeoIP-based locale detection:
 * - Skips fetch when user already has preferences (__localeAuto flags)
 * - Fetches /api/locale with fallback to /locale
 * - Maps backend response to app locale keys
 * - Only overrides auto-filled values, preserving user choices
 * - Dispatches currency-changed event when currency updates
 * - Handles timeout (900ms AbortController) and network failures gracefully
 * - Resets __localeAuto flags after completion
 *
 * Requirements: LOCALE-11, LOCALE-12
 */
```

**Important mock considerations:**
- locale.js uses `new URL('/api/locale', base)` which requires a valid base URL. Mock window.location.origin = 'http://localhost:3000' or similar.
- The AbortController in locale.js creates a real abort signal. If Happy-DOM supports AbortController, use it directly. If not, mock it:
  ```javascript
  const mockAbort = vi.fn();
  vi.stubGlobal('AbortController', class {
    constructor() {
      this.signal = { aborted: false };
      this.abort = mockAbort;
    }
  });
  ```
- For timeout tests with vi.useFakeTimers(), note that fetch promises need manual resolution. Create a pending promise that never resolves, advance timers to trigger abort, then verify the function completes.
  </action>
  <verify>Run `npx vitest run frontend/tests/locale/hydration.test.js` from the frontend directory. All tests pass.</verify>
  <done>18-22 tests covering GeoIP detection (LOCALE-11), fallback chain (LOCALE-12), preference respect, timeout handling, and event dispatch. hydrateLocaleFromBackend fully tested for happy path, error paths, and edge cases.</done>
</task>

<task type="auto">
  <name>Task 2: Create bidirectional text tests</name>
  <files>frontend/tests/locale/bidi.test.js</files>
  <action>
Create `frontend/tests/locale/bidi.test.js` test file.

This file tests LOCALE-10: bidirectional text handling for Hebrew names with English SKU codes.

**Key finding from research:** `categoriesView.js:627` has `<span class="sku-value" dir="ltr">` in the buildSkuBadge method. This is the only bidi handling in the codebase.

**Approach:** Test the buildSkuBadge method output to verify SKU values have dir="ltr". This can be done by:
1. Creating a CategoriesView instance (following patterns from Phase 20-02: suppress auto-init, mock fetch)
2. Calling buildSkuBadge() or the method that generates product cards
3. Parsing the returned HTML string for the dir="ltr" attribute

**Alternative simpler approach:** Since buildSkuBadge returns an HTML string, we can test the string directly without full View instantiation. Check if the method is accessible on the prototype.

Look at categoriesView.js to determine if buildSkuBadge is a method on the class. From research (line 627), it's within a method that generates product card markup. If it's an instance method, instantiate with minimal setup. If it's part of a larger template literal, extract the relevant test.

Test cases for bidi.test.js (~5-8 tests):

**SKU badge dir attribute:**
- Product card HTML contains `dir="ltr"` on SKU value span
- SKU value "TK-001" renders inside span.sku-value with dir="ltr"
- Empty SKU still generates placeholder without dir="ltr" issue

**Hebrew mode context:**
- When document.documentElement.dir = 'rtl' (Hebrew mode), SKU spans still have dir="ltr"
- This ensures English SKU codes are readable in RTL context

**Integration with product card:**
- Generate a product card for a product with SKU in Hebrew mode
- Verify the sku-value span has dir="ltr"
- Verify Hebrew product name text is NOT forced to dir="ltr"

**Limitation documentation comment:**
```javascript
/**
 * Bidirectional text tests.
 *
 * Verifies that English SKU codes display correctly in Hebrew (RTL) mode.
 * The app sets dir="ltr" on SKU value spans to force left-to-right rendering
 * for alphanumeric codes (e.g., "TK-001") within an RTL page layout.
 *
 * Limitation: No <bdi> elements are used for mixed-direction inline text.
 * Product titles in Hebrew do not have explicit bidi markup - they rely on
 * document-level dir="rtl" for correct rendering. This is acceptable for v1.3.
 *
 * Requirements: LOCALE-10
 */
```

**Setup pattern from Phase 20-02 for CategoriesView:**
- Set body.id to something other than 'categories' to suppress auto-init
- Mock fetch to prevent network calls
- Use fake timers if needed
- Mock process.cwd() for dotenv compatibility in model.js imports
- Follow patterns from frontend/tests/views/categories.test.js

If directly accessing the template generation method is difficult (e.g., it requires full product data flow), an alternative is to parse the HTML string returned by the method. Use a regex or DOM parsing to verify dir="ltr" presence.
  </action>
  <verify>Run `npx vitest run frontend/tests/locale/bidi.test.js` from the frontend directory. All tests pass.</verify>
  <done>5-8 tests verifying SKU elements have dir="ltr" in Hebrew mode (LOCALE-10). Bidi limitation documented (no bdi elements, acceptable for v1.3).</done>
</task>

</tasks>

<verification>
Run all locale tests together:
```bash
cd frontend && npx vitest run tests/locale/
```
All tests pass. Run full suite to verify no regressions:
```bash
cd frontend && npx vitest run
```

Requirements coverage after this plan:
- LOCALE-10: SKU dir="ltr" verified in Hebrew product cards
- LOCALE-11: GeoIP detection via fetchLocaleFromBackend tested
- LOCALE-12: Fallback chain (/api/locale -> /locale -> graceful failure) tested
</verification>

<success_criteria>
1. hydration.test.js has 18+ tests covering GeoIP fetch, fallback, timeout, and preference respect
2. bidi.test.js has 5+ tests verifying SKU dir="ltr" in Hebrew context
3. All tests pass with `npx vitest run tests/locale/`
4. currency-changed event dispatch verified in hydration tests
5. No regressions in existing test suite
</success_criteria>

<output>
After completion, create `.planning/phases/21-locale-currency-tests/21-02-SUMMARY.md`
</output>

---
phase: 05-product-ordering-backend
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - backend/index.js
autonomous: true

must_haves:
  truths:
    - "Admin can submit new product order via API and changes persist in database"
    - "Concurrent reorder attempts by multiple admins are handled safely (409 or both succeed)"
    - "API validates category scope (only products in same category can be reordered together)"
    - "Invalid reorder requests return clear, specific error messages"
  artifacts:
    - path: "backend/index.js"
      provides: "POST /api/admin/products/reorder endpoint"
      contains: "app.post.*api/admin/products/reorder"
  key_links:
    - from: "reorder endpoint"
      to: "Product.bulkWrite()"
      via: "version-checked update operations"
      pattern: "__v.*bulkWrite|bulkWrite.*__v"
    - from: "reorder endpoint"
      to: "fetchUser + requireAdmin middleware"
      via: "middleware chain"
      pattern: "fetchUser.*requireAdmin.*reorder"
---

<objective>
Create the product reordering API endpoint with validation and concurrency protection.

Purpose: Enable Phase 6 frontend to persist drag-and-drop reordering changes. This API is the bridge between admin UI actions and database state, with proper safeguards for concurrent admin operations.

Output: POST /api/admin/products/reorder endpoint that accepts {category, productIds[]}, validates the request, and atomically updates displayOrder values using optimistic concurrency control.
</objective>

<execution_context>
@C:\Users\pagis\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\pagis\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-product-ordering-backend/05-CONTEXT.md
@.planning/phases/05-product-ordering-backend/05-RESEARCH.md
@backend/models/Product.js
@backend/middleware/auth.js
@backend/index.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create reorder endpoint with validation</name>
  <files>backend/index.js</files>
  <action>
Add POST /api/admin/products/reorder endpoint to backend/index.js with:

**Route setup:**
```javascript
app.post(
  '/api/admin/products/reorder',
  adminRateLimiter,
  fetchUser,
  requireAdmin,
  async (req, res) => { ... }
);
```

**Request validation (inline, matching codebase patterns):**
1. Validate request body has `category` (non-empty string) and `productIds` (non-empty array)
2. Validate each productId is a valid MongoDB ObjectId (use mongoose.Types.ObjectId.isValid())
3. Check for duplicate productIds in array: `new Set(productIds).size === productIds.length`

**Business logic validation (after fetching from DB):**
1. Fetch all products: `Product.find({ _id: { $in: productIds } }).select('_id category __v')`
2. Check all products exist: `fetchedProducts.length === productIds.length`
   - If not: return 400 with specific message identifying missing IDs
3. Check all products belong to requested category
   - If mixed: return 400 with message listing conflicting categories
4. Check request includes all products in category:
   - Count: `Product.countDocuments({ category })`
   - If count !== productIds.length: return 400 with completeness error

**Error response format (matching existing codebase patterns):**
```javascript
res.status(400).json({
  success: false,
  errors: 'Specific error message here'
});
```

**Place endpoint near other admin routes** (around line 2200 where updateproduct/:id is).

Do NOT implement the bulkWrite update yet - that's Task 2. This task focuses on validation only. After validation passes, add a placeholder:
```javascript
// Task 2: bulkWrite implementation
res.json({ success: true, message: 'Validation passed', productIds });
```
  </action>
  <verify>
1. `node --check backend/index.js` passes (no syntax errors)
2. Grep confirms endpoint exists: `grep -n "api/admin/products/reorder" backend/index.js`
3. Grep confirms middleware chain: `grep -A2 "api/admin/products/reorder" backend/index.js | grep -E "fetchUser|requireAdmin"`
  </verify>
  <done>
Endpoint exists with validation that:
- Returns 400 if category or productIds missing/invalid
- Returns 400 if any productId is invalid ObjectId format
- Returns 400 if duplicate productIds in request
- Returns 400 if any product not found (with specific IDs)
- Returns 400 if products span multiple categories
- Returns 400 if not all category products included
- Returns 200 with placeholder response if all validation passes
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement bulkWrite with concurrency control</name>
  <files>backend/index.js</files>
  <action>
Replace the placeholder in Task 1 with actual bulkWrite implementation:

**Build version map from fetched products:**
```javascript
// fetchedProducts already has _id, category, __v from Task 1 validation
const versionMap = new Map(
  fetchedProducts.map(p => [p._id.toString(), p.__v])
);
```

**Build bulkWrite operations with version check:**
```javascript
const operations = productIds.map((productId, index) => ({
  updateOne: {
    filter: {
      _id: new mongoose.Types.ObjectId(productId),
      __v: versionMap.get(productId) // Optimistic concurrency check
    },
    update: {
      $set: { displayOrder: (index + 1) * 10 }, // Gap-based: 10, 20, 30...
      $inc: { __v: 1 } // Increment version
    }
  }
}));
```

**Execute with ordered: true for atomicity:**
```javascript
const result = await Product.bulkWrite(operations, { ordered: true });
```

**Detect concurrency conflict:**
```javascript
if (result.modifiedCount !== productIds.length) {
  // Some updates failed version check - another admin modified products
  return res.status(409).json({
    success: false,
    errors: 'Concurrency conflict detected. Another admin modified product order. Please refresh and try again.'
  });
}
```

**Success response:**
```javascript
res.json({
  success: true,
  message: `Product order updated for category '${category}'`,
  reorderedCount: result.modifiedCount
});
```

**Error handling:**
Wrap bulkWrite in try/catch. On error, return 500 with generic message (don't leak internal errors).
  </action>
  <verify>
1. `node --check backend/index.js` passes
2. Grep confirms bulkWrite usage: `grep -n "bulkWrite" backend/index.js`
3. Grep confirms __v version check: `grep -n "__v" backend/index.js | grep -i reorder`
4. Grep confirms 409 status for concurrency: `grep -n "409" backend/index.js`
  </verify>
  <done>
Endpoint now:
- Uses bulkWrite for atomic batch update (single DB round-trip)
- Checks __v version in filter to detect concurrent modifications
- Increments __v after update to invalidate stale clients
- Returns 409 if modifiedCount !== expected (concurrency conflict)
- Returns 200 with reorderedCount on success
- Assigns displayOrder as gap-based values (10, 20, 30...)
  </done>
</task>

</tasks>

<verification>
**API Contract Verification (manual curl tests after both tasks):**

1. **Auth required:**
   ```bash
   curl -X POST http://localhost:3001/api/admin/products/reorder \
     -H "Content-Type: application/json" \
     -d '{"category":"bracelets","productIds":[]}'
   # Expected: 401 Unauthorized
   ```

2. **Validation errors:**
   ```bash
   # With valid admin token:
   curl -X POST http://localhost:3001/api/admin/products/reorder \
     -H "Content-Type: application/json" \
     -H "auth-token: YOUR_ADMIN_TOKEN" \
     -d '{"category":"","productIds":[]}'
   # Expected: 400 with validation error
   ```

3. **Success case:**
   ```bash
   # Get actual product IDs from a category first, then:
   curl -X POST http://localhost:3001/api/admin/products/reorder \
     -H "Content-Type: application/json" \
     -H "auth-token: YOUR_ADMIN_TOKEN" \
     -d '{"category":"bracelets","productIds":["id1","id2","id3"]}'
   # Expected: 200 with reorderedCount
   ```

4. **Verify persistence:**
   ```bash
   # Query products to verify displayOrder values changed
   curl http://localhost:3001/getAllProductsByCategory \
     -H "Content-Type: application/json" \
     -d '{"category":"bracelets"}'
   # Products should be in new order
   ```

**Note:** These curl tests require running backend server and valid admin token. They verify the endpoint works as expected but are not automated tests.
</verification>

<success_criteria>
Phase 5 success criteria mapped to implementation:

1. **Admin can submit new product order via API and changes persist**
   - POST /api/admin/products/reorder accepts {category, productIds[]}
   - bulkWrite updates displayOrder values in database
   - Response includes reorderedCount confirming persistence

2. **Concurrent reorder attempts by multiple admins are handled safely**
   - __v version field checked in bulkWrite filter
   - modifiedCount validated after bulkWrite
   - 409 Conflict returned if version mismatch detected
   - No duplicate displayOrder values possible (gap-based numbering)

3. **API validates category scope**
   - All productIds validated to belong to requested category
   - 400 error if products span multiple categories
   - Full category reorder required (partial reorders rejected)

4. **Invalid reorder requests return clear error messages**
   - Missing category/productIds: "Category and productIds are required"
   - Invalid ObjectId format: "Invalid product ID format: {id}"
   - Duplicate IDs: "Duplicate product IDs in request"
   - Product not found: "Product not found: {id}"
   - Mixed categories: "Cannot reorder: products from multiple categories ({list})"
   - Incomplete: "Incomplete reorder: category '{cat}' has {n} products but request includes {m}"
</success_criteria>

<output>
After completion, create `.planning/phases/05-product-ordering-backend/05-01-SUMMARY.md`
</output>

---
phase: 01-database-foundation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - backend/models/Product.js
  - backend/index.js
autonomous: true

must_haves:
  truths:
    - "New products saved with valid SKU are stored successfully"
    - "New products without SKU are rejected with clear error message"
    - "Duplicate SKUs are rejected with user-friendly error showing conflicting product name"
    - "Existing products without SKUs load and display without errors"
    - "Edit operations can save unchanged SKU without duplicate error"
    - "SKU values are normalized (uppercase, trimmed) before storage"
    - "Invalid SKU format (special characters, wrong length) is rejected with clear error"
  artifacts:
    - path: "backend/models/Product.js"
      provides: "SKU field definition with validation"
      contains: "sku:"
    - path: "backend/index.js"
      provides: "SKU validation in addproduct and updateproduct routes"
      contains: "error.code === 11000"
  key_links:
    - from: "backend/index.js:/addproduct"
      to: "backend/models/Product.js:sku"
      via: "product.sku assignment"
      pattern: "sku.*req\\.body"
    - from: "backend/index.js:/updateproduct"
      to: "backend/models/Product.js:sku"
      via: "product.sku update"
      pattern: "product\\.sku"
---

<objective>
Add SKU field to Product schema with validation and integrate SKU handling into product API routes.

Purpose: Establish the data foundation for SKU management - proper schema definition with uniqueness constraints and API-level validation that returns user-friendly error messages. This enables Phase 2 (admin UI) to have a reliable backend.

Output: Modified Product model with SKU field; updated addproduct and updateproduct routes with SKU validation and error handling.
</objective>

<execution_context>
@C:\Users\pagis\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\pagis\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-database-foundation/01-CONTEXT.md
@.planning/phases/01-database-foundation/01-RESEARCH.md
@backend/models/Product.js
@backend/index.js (lines 1609-1906 for /addproduct, lines 1908-2107 for /updateproduct/:id)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add SKU field to Product schema</name>
  <files>backend/models/Product.js</files>
  <action>
Add SKU field to ProductSchema with the following configuration:

```javascript
sku: {
  type: String,
  uppercase: true,        // Auto-transform to uppercase (handles abc123 -> ABC123)
  trim: true,             // Auto-trim whitespace
  sparse: true,           // Allow multiple documents without SKU (for existing products)
  unique: true,           // Prevent duplicates when SKU is present
  minLength: [2, 'SKU must be at least 2 characters'],
  maxLength: [7, 'SKU must be at most 7 characters'],
  validate: {
    validator: function(v) {
      // Allow empty/null for existing products (backwards compatibility)
      if (!v) return true;
      // Only alphanumeric after uppercase transform
      return /^[A-Z0-9]+$/.test(v);
    },
    message: 'SKU must contain only letters and numbers (A-Z, 0-9)'
  }
}
```

Add this field after the `security_margin` field (at end of schema before closing brace).

Also add explicit sparse unique index after schema definition:
```javascript
ProductSchema.index({ sku: 1 }, { unique: true, sparse: true });
```

IMPORTANT: Do NOT add `default: null` - Mongoose treats explicit null as a value which could cause uniqueness issues with sparse indexes. Leave undefined for existing products.
  </action>
  <verify>
1. Check syntax: `cd backend && node -e "require('./models/Product.js'); console.log('Product model loads OK')"`
2. Verify schema has SKU field with correct options
  </verify>
  <done>
Product.js loads without errors and contains SKU field with uppercase, trim, sparse, unique, minLength, maxLength, and custom validator configuration.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add SKU validation to product API routes</name>
  <files>backend/index.js</files>
  <action>
Update `/addproduct` route (around line 1629, after existing input guards):

1. Add SKU validation guard after the mainImage check:
```javascript
// SKU validation for new products
const rawSku = req.body.sku;
if (!rawSku || (typeof rawSku === 'string' && rawSku.trim() === '')) {
  return res.status(400).json({
    success: false,
    error: 'SKU is required for new products'
  });
}

// Normalize and validate SKU format before saving
const normalizedSku = String(rawSku).trim().toUpperCase();
if (normalizedSku.length < 2 || normalizedSku.length > 7) {
  return res.status(400).json({
    success: false,
    error: 'SKU must be between 2 and 7 characters'
  });
}
if (!/^[A-Z0-9]+$/.test(normalizedSku)) {
  return res.status(400).json({
    success: false,
    error: 'SKU must contain only letters and numbers (A-Z, 0-9). No spaces or special characters allowed.'
  });
}
```

2. Add SKU to product creation object (around line 1836):
```javascript
sku: normalizedSku,
```

3. Update the catch block (around line 1883) to handle E11000 duplicate key errors with user-friendly messages:
```javascript
} catch (error) {
  // Handle duplicate SKU error
  if (error.code === 11000 && error.keyPattern?.sku) {
    const duplicateSku = error.keyValue?.sku;
    // Find conflicting product name for better error message
    const existingProduct = await Product.findOne({ sku: duplicateSku }).select('name');
    return res.status(409).json({
      success: false,
      error: `SKU '${duplicateSku}' is already used by ${existingProduct?.name || 'another product'}. Please choose a different SKU.`
    });
  }

  // Handle Mongoose validation errors
  if (error.name === 'ValidationError') {
    const messages = Object.values(error.errors).map(e => e.message);
    return res.status(400).json({
      success: false,
      error: messages.join('. ')
    });
  }

  // ... rest of existing error handling
```

Update `/updateproduct/:id` route (around line 1935, after extracting form data):

1. Add SKU to extracted form data:
```javascript
const {
  name,
  ils_price,
  description,
  category,
  quantity,
  security_margin,
  sku,  // Add this
} = req.body;
```

2. Add SKU update logic after `product.security_margin = ...` (around line 1976):
```javascript
// Handle SKU update
// Only validate if SKU is being changed (not if it's the same or not provided)
if (sku !== undefined) {
  const normalizedSku = sku ? String(sku).trim().toUpperCase() : null;

  // If setting a SKU value (not clearing it)
  if (normalizedSku) {
    // Validate format
    if (normalizedSku.length < 2 || normalizedSku.length > 7) {
      return res.status(400).json({
        success: false,
        message: 'SKU must be between 2 and 7 characters'
      });
    }
    if (!/^[A-Z0-9]+$/.test(normalizedSku)) {
      return res.status(400).json({
        success: false,
        message: 'SKU must contain only letters and numbers (A-Z, 0-9)'
      });
    }
  }

  product.sku = normalizedSku;
}
```

3. Update the catch block (around line 2100) to handle E11000 errors:
```javascript
} catch (error) {
  // Handle duplicate SKU error
  if (error.code === 11000 && error.keyPattern?.sku) {
    const duplicateSku = error.keyValue?.sku;
    const existingProduct = await Product.findOne({ sku: duplicateSku }).select('name');
    return res.status(409).json({
      success: false,
      message: `SKU '${duplicateSku}' is already used by ${existingProduct?.name || 'another product'}. Please choose a different SKU.`
    });
  }

  // Handle Mongoose validation errors
  if (error.name === 'ValidationError') {
    const messages = Object.values(error.errors).map(e => e.message);
    return res.status(400).json({
      success: false,
      message: messages.join('. ')
    });
  }

  console.error('Error updating product:', error);
  res.status(500).json({
    success: false,
    message: error.message,
  });
}
```

NOTES:
- Use `error` key in addproduct responses (existing pattern)
- Use `message` key in updateproduct responses (existing pattern)
- HTTP 409 Conflict for duplicate SKU errors
- HTTP 400 Bad Request for validation errors
- Edit operations: MongoDB unique index automatically excludes the document being updated, so no special self-exclusion logic needed
  </action>
  <verify>
1. Start backend: `cd backend && npm run devStart`
2. Test new product without SKU is rejected (should get 400 error)
3. Test new product with valid SKU works
4. Test duplicate SKU is rejected with 409 and user-friendly message
5. Test existing products still load (backwards compatibility)
  </verify>
  <done>
- /addproduct requires SKU and validates format/uniqueness with user-friendly errors
- /updateproduct/:id accepts optional SKU updates with same validation
- E11000 duplicate key errors transformed into user-friendly messages showing conflicting product name
- Existing products without SKU continue to work
  </done>
</task>

</tasks>

<verification>
## Backend Verification

1. **Schema loads:** `cd backend && node -e "require('./models/Product.js'); console.log('OK')"`

2. **Server starts:** `cd backend && npm run devStart` (should start without errors)

3. **Manual API tests (using curl or Postman with valid admin auth):**
   - POST /addproduct without SKU -> 400 "SKU is required"
   - POST /addproduct with SKU="AB" -> creates product (min length valid)
   - POST /addproduct with SKU="A" -> 400 "must be at least 2 characters"
   - POST /addproduct with SKU="ABCDEFGH" -> 400 "must be at most 7 characters"
   - POST /addproduct with SKU="AB-1" -> 400 "only letters and numbers"
   - POST /addproduct with duplicate SKU -> 409 "already used by [ProductName]"
   - POST /updateproduct/:id with new valid SKU -> 200 success
   - POST /updateproduct/:id with same SKU as another product -> 409 duplicate error

4. **Backwards compatibility:** Existing products in database should load via /allproducts without errors
</verification>

<success_criteria>
1. Product schema includes SKU field with uppercase, trim, sparse unique index, and alphanumeric validation
2. New products require SKU - rejected with 400 if missing
3. Invalid SKU format rejected with 400 and clear error message
4. Duplicate SKU rejected with 409 and message showing conflicting product name
5. Existing products without SKU continue to function (load, display, update other fields)
6. Edit operations can update SKU without false duplicate errors
7. Backend starts without errors and all existing functionality preserved
</success_criteria>

<output>
After completion, create `.planning/phases/01-database-foundation/01-01-SUMMARY.md`
</output>

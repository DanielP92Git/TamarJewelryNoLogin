---
phase: 04-schema-foundation-library-setup
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - backend/package.json
  - backend/migrate-mongo-config.js
  - backend/migrations/YYYYMMDDHHMMSS-add-product-display-order.js
  - backend/models/Product.js
autonomous: true

must_haves:
  truths:
    - "Every existing product has a displayOrder integer field assigned"
    - "Products are ordered by creation date (newest first) within each category"
    - "Migration can be rolled back to remove displayOrder field"
    - "New products automatically get displayOrder assigned"
  artifacts:
    - path: "backend/migrate-mongo-config.js"
      provides: "Database connection settings for migrate-mongo"
      contains: "module.exports"
    - path: "backend/migrations/"
      provides: "Migration scripts directory"
    - path: "backend/models/Product.js"
      provides: "displayOrder field in schema"
      contains: "displayOrder"
  key_links:
    - from: "backend/migrate-mongo-config.js"
      to: "MongoDB connection"
      via: "MONGODB_URI environment variable"
      pattern: "process\\.env\\.MONGODB_URI|mongodb"
    - from: "backend/migrations/*-add-product-display-order.js"
      to: "products collection"
      via: "db.collection('products')"
      pattern: "db\\.collection\\(['\"]products['\"]\\)"
    - from: "backend/models/Product.js"
      to: "displayOrder index"
      via: "compound index"
      pattern: "category.*displayOrder.*available|index.*displayOrder"
---

<objective>
Establish database migration infrastructure and add displayOrder field to Product schema for category-scoped product ordering.

Purpose: Enable future drag-and-drop product reordering by laying the database foundation (FOUND-01, FOUND-02, FOUND-03 requirements).
Output: Migration tooling installed, migration script with rollback support, Product schema updated with displayOrder field and compound index.
</objective>

<execution_context>
@C:\Users\pagis\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\pagis\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-schema-foundation-library-setup/04-CONTEXT.md
@.planning/phases/04-schema-foundation-library-setup/04-RESEARCH.md
@backend/models/Product.js
@backend/package.json
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install migrate-mongo and create configuration</name>
  <files>backend/package.json, backend/migrate-mongo-config.js</files>
  <action>
1. Install migrate-mongo as a dev dependency:
   ```bash
   cd backend && npm install --save-dev migrate-mongo
   ```

2. Create `backend/migrate-mongo-config.js` with configuration that:
   - Uses `process.env.MONGODB_URI` for database connection (same env var as main app)
   - Falls back to localhost for development: `mongodb://localhost:27017/jewelry` (or whatever default the app uses)
   - Sets migrations directory to `./migrations`
   - Sets changelog collection to `changelog` (default migrate-mongo behavior)
   - IMPORTANT: Do NOT include hardcoded production credentials - use environment variable only

Configuration template:
```javascript
require('dotenv').config();

const config = {
  mongodb: {
    url: process.env.MONGODB_URI || 'mongodb://localhost:27017/jewelry',
    options: {
      useNewUrlParser: true,
      useUnifiedTopology: true,
    }
  },
  migrationsDir: 'migrations',
  changelogCollectionName: 'changelog',
  migrationFileExtension: '.js',
  useFileHash: false,
  moduleSystem: 'commonjs',
};

module.exports = config;
```

3. Add npm scripts to backend/package.json for migration commands:
   - "migrate:up": "migrate-mongo up"
   - "migrate:down": "migrate-mongo down"
   - "migrate:status": "migrate-mongo status"

4. Create empty `backend/migrations/` directory (migrate-mongo will put scripts here)
  </action>
  <verify>
- Run `cd backend && npm run migrate:status` - should show "No migrations found" or similar
- Verify migrate-mongo-config.js exists and exports valid config object
- Verify migrations/ directory exists
  </verify>
  <done>
- migrate-mongo installed as dev dependency in backend/package.json
- migrate-mongo-config.js exists with proper environment variable usage
- npm scripts for migrate:up, migrate:down, migrate:status added
- migrations/ directory created
  </done>
</task>

<task type="auto">
  <name>Task 2: Create displayOrder migration script with rollback</name>
  <files>backend/migrations/YYYYMMDDHHMMSS-add-product-display-order.js</files>
  <action>
Create migration script using `migrate-mongo create add-product-display-order` or manually create file.

The migration script must implement:

**up() function:**
1. Validate all products have category field (fail migration if any orphaned products exist)
2. Get distinct categories from products collection
3. For each category, query products sorted by `createdAt: -1` (newest first per CONTEXT.md decision)
4. Assign gap-based displayOrder values: 10, 20, 30... (gap of 10 per RESEARCH.md recommendation)
5. Use bulkWrite for efficient batch updates (not individual updates)
6. Create compound index: `{category: 1, displayOrder: 1, available: 1}` with name `category_displayOrder_available_idx`
7. Log progress: category name, product count assigned

**down() function (rollback):**
1. Drop the compound index `category_displayOrder_available_idx`
2. Remove displayOrder field from all products using `$unset`
3. Log rollback completion

**Critical implementation details:**
- Use gap-based numbering (10, 20, 30) not sequential (1, 2, 3) - allows insertions without renumbering
- Sort by createdAt descending (newest first) to assign initial order
- Validate category existence BEFORE any modifications (fail fast)
- Use db.collection('products') directly (not Mongoose model) for migration portability

Migration file template:
```javascript
module.exports = {
  async up(db) {
    const products = db.collection('products');

    // 1. Validate: Check all products have category field
    const noCategoryCount = await products.countDocuments({
      $or: [
        { category: { $exists: false } },
        { category: null },
        { category: '' }
      ]
    });
    if (noCategoryCount > 0) {
      throw new Error(
        `Migration blocked: ${noCategoryCount} products missing category field. ` +
        `Fix before running migration.`
      );
    }

    // 2. Get distinct categories
    const categories = await products.distinct('category');
    console.log(`Found ${categories.length} categories: ${categories.join(', ')}`);

    // 3. For each category, assign displayOrder based on createdAt (newest first)
    for (const category of categories) {
      const categoryProducts = await products
        .find({ category })
        .sort({ createdAt: -1 })  // Newest first
        .toArray();

      if (categoryProducts.length === 0) continue;

      const bulkOps = categoryProducts.map((product, index) => ({
        updateOne: {
          filter: { _id: product._id },
          update: { $set: { displayOrder: (index + 1) * 10 } }  // Gap-based: 10, 20, 30...
        }
      }));

      await products.bulkWrite(bulkOps);
      console.log(`  ${category}: ${categoryProducts.length} products assigned displayOrder`);
    }

    // 4. Create compound index (ESR rule: Equality, Sort, Range)
    await products.createIndex(
      { category: 1, displayOrder: 1, available: 1 },
      { name: 'category_displayOrder_available_idx' }
    );
    console.log('Created compound index: category_displayOrder_available_idx');

    // 5. Log total
    const totalWithOrder = await products.countDocuments({ displayOrder: { $exists: true } });
    console.log(`Migration complete: ${totalWithOrder} products now have displayOrder`);
  },

  async down(db) {
    const products = db.collection('products');

    // 1. Drop the compound index
    try {
      await products.dropIndex('category_displayOrder_available_idx');
      console.log('Dropped index: category_displayOrder_available_idx');
    } catch (err) {
      console.log('Index may not exist, continuing...');
    }

    // 2. Remove displayOrder field from all products
    const result = await products.updateMany(
      {},
      { $unset: { displayOrder: '' } }
    );
    console.log(`Rollback complete: removed displayOrder from ${result.modifiedCount} products`);
  }
};
```
  </action>
  <verify>
- Migration file exists in backend/migrations/ with proper timestamp prefix
- File has both up() and down() functions exported
- Run `npm run migrate:status` to confirm migration is detected as "PENDING"
  </verify>
  <done>
- Migration script created with up() that assigns displayOrder to all products
- Migration script has down() rollback that removes displayOrder field
- Gap-based numbering (10, 20, 30) implemented
- Compound index creation included in up()
- Category validation prevents running on orphaned products
  </done>
</task>

<task type="auto">
  <name>Task 3: Update Product schema with displayOrder field</name>
  <files>backend/models/Product.js</files>
  <action>
Update the existing Product.js schema to include displayOrder field for new products created AFTER migration.

Add to ProductSchema:
```javascript
displayOrder: {
  type: Number,
  index: true,  // For efficient sorting (compound index handles category-scoped queries)
  default: null,  // Will be set by pre-save hook for new products
  min: [1, 'displayOrder must be positive']
}
```

Add pre-save hook to auto-assign displayOrder for new products:
```javascript
// Pre-save hook: Auto-assign displayOrder for new products
ProductSchema.pre('save', async function(next) {
  // Only assign displayOrder for new documents without one
  if (this.isNew && this.displayOrder == null && this.category) {
    try {
      const Product = this.constructor;
      // Find highest displayOrder in the same category
      const maxProduct = await Product.findOne({ category: this.category })
        .sort({ displayOrder: -1 })
        .select('displayOrder')
        .lean();

      // Assign next gap-based value (10 higher than max, or 10 if first)
      this.displayOrder = maxProduct?.displayOrder
        ? maxProduct.displayOrder + 10
        : 10;
    } catch (err) {
      console.error('Error assigning displayOrder:', err);
      // Continue without displayOrder if there's an error
    }
  }
  next();
});
```

IMPORTANT placement:
- Add displayOrder field AFTER the sku field in the schema definition
- Add pre-save hook AFTER the schema definition but BEFORE module.exports
- Do NOT add a second compound index here - the migration creates it

Why this design:
- Migration handles existing products (assigns displayOrder based on createdAt)
- Pre-save hook handles NEW products (appends to end of category)
- Gap-based numbering (multiples of 10) maintained for both
  </action>
  <verify>
- Backend server starts without errors: `cd backend && npm run devStart` (start and check for Mongoose errors, then Ctrl+C)
- Product schema includes displayOrder field
- Pre-save hook exists and references displayOrder
- No duplicate index definitions (migration handles compound index)
  </verify>
  <done>
- Product.js has displayOrder field with type Number
- Pre-save hook auto-assigns displayOrder for new products
- New products append to bottom of category (highest displayOrder + 10)
- Schema maintains backwards compatibility (existing products work until migration runs)
  </done>
</task>

</tasks>

<verification>
After all tasks complete:

1. **Migration tooling works:**
   ```bash
   cd backend && npm run migrate:status
   ```
   Should show the add-product-display-order migration as PENDING

2. **Schema valid:**
   ```bash
   cd backend && npm run devStart
   ```
   Server should start without Mongoose schema errors (Ctrl+C to exit)

3. **Migration ready to run:**
   - migrate-mongo-config.js exists with env var for MONGODB_URI
   - Migration file has up() and down() methods
   - Product schema has displayOrder field

NOTE: Do NOT run the migration yet - that happens manually by user against their database.
The migration is PREPARED but not EXECUTED in this plan.
</verification>

<success_criteria>
- [ ] migrate-mongo installed as dev dependency
- [ ] migrate-mongo-config.js created with environment variable usage
- [ ] npm scripts added: migrate:up, migrate:down, migrate:status
- [ ] Migration script exists with up() and down() functions
- [ ] Migration assigns gap-based displayOrder (10, 20, 30) sorted by createdAt descending
- [ ] Migration creates compound index {category, displayOrder, available}
- [ ] Product.js schema includes displayOrder field
- [ ] Pre-save hook assigns displayOrder to new products
- [ ] Backend server starts without errors
</success_criteria>

<output>
After completion, create `.planning/phases/04-schema-foundation-library-setup/04-01-SUMMARY.md`
</output>

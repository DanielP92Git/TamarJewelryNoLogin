---
phase: 04-schema-foundation-library-setup
plan: 03
type: execute
wave: 1
depends_on: []
files_modified:
  - backend/models/Product.js
  - backend/index.js
autonomous: true
gap_closure: true

must_haves:
  truths:
    - "Products can be queried efficiently in sorted order per category"
    - "Category product listings return items in admin-defined display order"
    - "Compound index persists across schema changes and model recompilation"
  artifacts:
    - path: "backend/models/Product.js"
      provides: "Compound index declaration for category+displayOrder+available"
      contains: "ProductSchema.index.*category.*displayOrder.*available"
    - path: "backend/index.js"
      provides: "Sorted category queries"
      contains: ".sort.*displayOrder"
  key_links:
    - from: "backend/models/Product.js"
      to: "MongoDB compound index"
      via: "ProductSchema.index() declaration"
      pattern: "ProductSchema\\.index\\(\\s*\\{\\s*category"
    - from: "backend/index.js /productsByCategory"
      to: "displayOrder field"
      via: ".sort({displayOrder: 1})"
      pattern: "\\.sort\\(\\s*\\{\\s*displayOrder"
    - from: "backend/index.js /chunkProducts"
      to: "displayOrder field"
      via: ".sort({displayOrder: 1})"
      pattern: "\\.sort\\(\\s*\\{\\s*displayOrder"
    - from: "backend/index.js /getAllProductsByCategory"
      to: "displayOrder field"
      via: ".sort({displayOrder: 1})"
      pattern: "\\.sort\\(\\s*\\{\\s*displayOrder"
---

<objective>
Close verification gaps in Phase 4 by adding the compound index declaration to Product schema and adding displayOrder sorting to all category-filtered product queries.

Purpose: The displayOrder field exists but is not being used - queries return products in arbitrary order (by _id) instead of admin-defined order. This defeats the purpose of the entire reordering feature.

Output: Product queries return items sorted by displayOrder; compound index declared in schema for persistence.
</objective>

<execution_context>
@C:\Users\pagis\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\pagis\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/04-schema-foundation-library-setup/04-01-SUMMARY.md
@.planning/phases/04-schema-foundation-library-setup/04-VERIFICATION.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add compound index declaration to Product schema</name>
  <files>backend/models/Product.js</files>
  <action>
Add the compound index declaration to Product.js after the existing SKU index (around line 71).

The index must be declared in the schema so Mongoose knows about it - the migration creates it but that's fragile if schema changes later.

Add this code after the SKU index line:

```javascript
// Compound index for category-scoped product ordering (ESR: Equality-Sort-Range)
// Declared here in addition to migration to ensure persistence across schema changes
ProductSchema.index(
  { category: 1, displayOrder: 1, available: 1 },
  { name: 'category_displayOrder_available_idx' }
);
```

WHY: Migration creates the index but if schema is modified and re-applied, Mongoose may drop indexes it doesn't know about. Declaring it in schema makes it authoritative.
  </action>
  <verify>
Run: grep -n "category_displayOrder_available" backend/models/Product.js
Should show the index declaration with the named index.
  </verify>
  <done>Product schema declares compound index {category: 1, displayOrder: 1, available: 1} with explicit name</done>
</task>

<task type="auto">
  <name>Task 2: Add displayOrder sorting to category product queries</name>
  <files>backend/index.js</files>
  <action>
Add `.sort({ displayOrder: 1 })` to three category-filtered product endpoints. This ensures products are returned in admin-defined order instead of arbitrary _id order.

**Endpoint 1: /productsByCategory (around line 2636)**
Change from:
```javascript
let products = await Product.find({
  category: category,
  quantity: { $gt: 0 },
  available: { $ne: false },
})
  .lean()
  .skip(skip)
  .limit(limit);
```

To:
```javascript
let products = await Product.find({
  category: category,
  quantity: { $gt: 0 },
  available: { $ne: false },
})
  .sort({ displayOrder: 1 })
  .lean()
  .skip(skip)
  .limit(limit);
```

**Endpoint 2: /chunkProducts (around line 2663)**
Change from:
```javascript
const products = await Product.find({
  category: category,
  quantity: { $gt: 0 },
  available: { $ne: false },
})
  .lean()
  .skip(skip)
  .limit(limit);
```

To:
```javascript
const products = await Product.find({
  category: category,
  quantity: { $gt: 0 },
  available: { $ne: false },
})
  .sort({ displayOrder: 1 })
  .lean()
  .skip(skip)
  .limit(limit);
```

**Endpoint 3: /getAllProductsByCategory (around line 2689)**
Change from:
```javascript
const products = await Product.find({
  category: category,
  quantity: { $gt: 0 },
  available: { $ne: false },
}).lean();
```

To:
```javascript
const products = await Product.find({
  category: category,
  quantity: { $gt: 0 },
  available: { $ne: false },
})
  .sort({ displayOrder: 1 })
  .lean();
```

WHY: Without sorting, MongoDB returns documents in natural order (insertion/update order) which is essentially random from a user perspective. The displayOrder field is useless until queries use it.

NOTE: The compound index {category, displayOrder, available} follows ESR (Equality-Sort-Range) guideline - category is equality, displayOrder is sort. This means these sorted queries will use the index efficiently.
  </action>
  <verify>
Run: grep -n "sort.*displayOrder" backend/index.js
Should show 3 matches at the three endpoint locations.

Run: cd backend && npm run lint (if available) or node --check index.js
Should pass without syntax errors.
  </verify>
  <done>All three category product endpoints sort by displayOrder ascending; storefront will show products in admin-defined order</done>
</task>

</tasks>

<verification>
1. **Schema check**: Product.js contains compound index declaration with name
2. **Query check**: All three category endpoints have .sort({ displayOrder: 1 })
3. **Syntax check**: Backend starts without errors (npm run devStart or node --check)
4. **Pattern check**: Queries follow pattern: .find({category}).sort({displayOrder}).lean()
</verification>

<success_criteria>
- [ ] ProductSchema.index() declares {category: 1, displayOrder: 1, available: 1} compound index
- [ ] /productsByCategory endpoint sorts by displayOrder
- [ ] /chunkProducts endpoint sorts by displayOrder
- [ ] /getAllProductsByCategory endpoint sorts by displayOrder
- [ ] Backend starts without Mongoose/syntax errors
- [ ] Grep confirms 3 sort occurrences in index.js for displayOrder
</success_criteria>

<output>
After completion, create `.planning/phases/04-schema-foundation-library-setup/04-03-SUMMARY.md`
</output>

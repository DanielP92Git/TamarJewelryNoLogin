---
phase: 06-frontend-product-reordering
plan: 03
type: execute
wave: 3
depends_on: ["06-02"]
files_modified:
  - admin/BisliView.js
  - admin/bambaYafa-desktop.css
autonomous: true

must_haves:
  truths:
    - "Admin can save reordered products and changes persist to database"
    - "Loading state displays while saving order"
    - "Success toast appears after successful save"
    - "Error toast appears with user-friendly message on failure"
    - "409 conflict auto-refreshes product list and shows notification"
    - "Unsaved changes warning appears when navigating away"
    - "Customer-facing product display reflects admin-defined order"
  artifacts:
    - path: "admin/BisliView.js"
      provides: "API integration for reorder endpoint"
      contains: "saveProductOrder"
  key_links:
    - from: "admin/BisliView.js"
      to: "/api/admin/products/reorder"
      via: "fetch POST with productIds array"
      pattern: "api/admin/products/reorder"
    - from: "admin/BisliView.js"
      to: "beforeunload event"
      via: "window.addEventListener"
      pattern: "beforeunload"
---

<objective>
Connect drag-and-drop UI to backend API, implement save workflow with loading states, error handling, 409 conflict resolution, and unsaved changes warning.

Purpose: Complete the reorder feature by wiring the UI to the Phase 5 API. Handles the full save lifecycle including loading overlay, success/error feedback, and optimistic concurrency conflict (409) with auto-refresh.

Output: Fully functional product reordering that persists to database, with proper UX for all states.
</objective>

<execution_context>
@C:\Users\pagis\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\pagis\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/06-frontend-product-reordering/06-CONTEXT.md
@.planning/phases/06-frontend-product-reordering/06-RESEARCH.md
@.planning/phases/05-product-ordering-backend/05-01-SUMMARY.md
@.planning/phases/06-frontend-product-reordering/06-02-SUMMARY.md

@admin/BisliView.js
@admin/bambaYafa-desktop.css
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement loading overlay and save function</name>
  <files>admin/BisliView.js, admin/bambaYafa-desktop.css</files>
  <action>
1. Add loading overlay CSS to bambaYafa-desktop.css:
   ```css
   /* Loading Overlay for Reorder Save */
   .reorder-loading-overlay {
     position: absolute;
     top: 0;
     left: 0;
     right: 0;
     bottom: 0;
     background: rgba(255, 255, 255, 0.85);
     display: flex;
     flex-direction: column;
     align-items: center;
     justify-content: center;
     z-index: 1000;
     pointer-events: all;
   }

   .reorder-loading-overlay .spinner {
     width: 40px;
     height: 40px;
     border: 3px solid #e5e5e5;
     border-top-color: #3b82f6;
     border-radius: 50%;
     animation: spin 0.8s linear infinite;
   }

   .reorder-loading-overlay p {
     margin-top: 12px;
     color: #4b5563;
     font-size: 14px;
   }

   @keyframes spin {
     to { transform: rotate(360deg); }
   }

   /* Make product list container position relative for overlay */
   .listproduct-allproducts {
     position: relative;
   }
   ```

2. Add loading overlay functions to BisliView.js:
   ```javascript
   function showReorderLoadingOverlay() {
     const container = document.querySelector('.listproduct-allproducts');
     if (!container) return;

     // Remove existing overlay if any
     hideReorderLoadingOverlay();

     const overlay = document.createElement('div');
     overlay.className = 'reorder-loading-overlay';
     overlay.innerHTML = `
       <div class="spinner"></div>
       <p>Saving order...</p>
     `;
     container.appendChild(overlay);
   }

   function hideReorderLoadingOverlay() {
     const overlay = document.querySelector('.reorder-loading-overlay');
     if (overlay) overlay.remove();
   }
   ```

3. Implement saveProductOrder function:
   ```javascript
   async function saveProductOrder() {
     if (!state.undoManager || !state.undoManager.hasChanges()) {
       showInfoToast('No changes to save');
       return;
     }

     const category = state.selectedCategory;
     const productIds = state.undoManager.getCurrentOrder();

     showReorderLoadingOverlay();
     updateReorderButtonStates(true); // Disable all buttons

     try {
       const response = await apiFetch('/api/admin/products/reorder', {
         method: 'POST',
         headers: {
           'Content-Type': 'application/json',
           'auth-token': localStorage.getItem('auth-token')
         },
         body: JSON.stringify({
           category: category,
           productIds: productIds
         })
       });

       const data = await response.json();

       hideReorderLoadingOverlay();

       if (response.status === 409) {
         // Concurrency conflict - another admin modified products
         showErrorToast('Product list was updated by another admin. Refreshing...');
         exitReorderMode();
         await fetchInfo(); // Reload products from server
         return;
       }

       if (!response.ok) {
         const errorMsg = data.errors || data.message || 'Failed to save order';
         showErrorToast(errorMsg);
         updateReorderButtonStates(); // Re-enable buttons
         return;
       }

       // Success
       showSuccessToast('Order saved successfully!');
       exitReorderMode();

       // Update local product order to match saved order
       // This ensures the list stays in the new order without refetch
       if (state.products) {
         const orderedProducts = productIds.map(id =>
           state.products.find(p => p.id === id)
         ).filter(Boolean);

         // Update products that were reordered
         const otherProducts = state.products.filter(p => p.category !== category);
         state.products = [...otherProducts, ...orderedProducts];
       }

       // Reload to get fresh displayOrder values from server
       await fetchInfo();

     } catch (error) {
       hideReorderLoadingOverlay();
       console.error('Error saving product order:', error);
       showErrorToast('Network error. Please check connection and try again.');
       updateReorderButtonStates(); // Re-enable buttons
     }
   }
   ```

4. Add save button event listener in loadProductsPage():
   ```javascript
   const saveReorderBtn = document.getElementById('saveReorderBtn');
   if (saveReorderBtn) {
     saveReorderBtn.addEventListener('click', saveProductOrder);
   }
   ```
  </action>
  <verify>
1. Enter reorder mode, drag products to reorder
2. Click 'Save Order'
3. Verify: Loading overlay appears with spinner and "Saving order..."
4. Verify: All action bar buttons disabled during save
5. On success: Green toast "Order saved successfully!", exits reorder mode
6. Refresh page - verify new order persists
  </verify>
  <done>Loading overlay displays during save, API call to POST /api/admin/products/reorder works, success/error handling complete with appropriate toasts.</done>
</task>

<task type="auto">
  <name>Task 2: Implement beforeunload warning for unsaved changes</name>
  <files>admin/BisliView.js</files>
  <action>
1. Add beforeunload handler function:
   ```javascript
   function handleBeforeUnload(event) {
     // Only block if in reorder mode with unsaved changes
     if (!state.isReorderMode) return;
     if (!state.undoManager || !state.undoManager.hasChanges()) return;

     // Modern browsers show generic message, custom message ignored
     event.preventDefault();
     event.returnValue = ''; // Required for Chrome
   }
   ```

2. Update enterReorderMode() to add beforeunload listener:
   ```javascript
   // Add after keyboard listener
   window.addEventListener('beforeunload', handleBeforeUnload);
   ```

3. Update exitReorderMode() to remove beforeunload listener:
   ```javascript
   // Add after keyboard listener removal
   window.removeEventListener('beforeunload', handleBeforeUnload);
   ```

4. Add internal navigation warning for SPA-style navigation.
   Create a guard function that checks before changing pages:
   ```javascript
   function canExitReorderMode() {
     if (!state.isReorderMode) return true;
     if (!state.undoManager || !state.undoManager.hasChanges()) return true;

     return confirm('You have unsaved changes. Discard and leave?');
   }
   ```

5. Update navigation handlers (sidebar buttons) to check guard:
   Find where productsListBtn and addProductsBtn click handlers are set and wrap them:
   ```javascript
   // In the init/setup section where nav handlers are bound:
   productsListBtn?.addEventListener('click', async () => {
     if (!canExitReorderMode()) return;
     if (state.isReorderMode) exitReorderMode();
     await fetchInfo();
   });

   addProductsBtn?.addEventListener('click', () => {
     if (!canExitReorderMode()) return;
     if (state.isReorderMode) exitReorderMode();
     loadAddProductPage();
   });
   ```
  </action>
  <verify>
1. Enter reorder mode and drag some products
2. Try to close browser tab - browser should show "Leave site?" warning
3. Try to click "Add Product" in sidebar - confirm dialog should appear
4. Click cancel in confirm - should stay in reorder mode
5. Save changes, then try to navigate - no warning should appear
  </verify>
  <done>beforeunload prevents accidental tab close, internal navigation prompts confirm dialog when unsaved changes exist.</done>
</task>

<task type="auto">
  <name>Task 3: Verify customer-facing order and add empty state handling</name>
  <files>admin/BisliView.js, admin/bambaYafa-desktop.css</files>
  <action>
1. Add empty state message for reorder mode when no products:
   In enterReorderMode(), the check already exists but improve the message:
   ```javascript
   const products = getFilteredProducts();
   if (products.length === 0) {
     showErrorToast('No products in this category to reorder');
     return;
   }

   if (products.length === 1) {
     showInfoToast('Only one product in category - nothing to reorder');
     return;
   }
   ```

2. Add CSS for empty state styling:
   ```css
   /* Empty State in Product List */
   .empty-state-reorder {
     padding: 48px 24px;
     text-align: center;
     color: #6b7280;
   }

   .empty-state-reorder h3 {
     margin: 0 0 8px 0;
     font-size: 18px;
     font-weight: 600;
     color: #374151;
   }

   .empty-state-reorder p {
     margin: 0;
     font-size: 14px;
   }
   ```

3. Update getFilteredProducts() to ensure it correctly gets products:
   ```javascript
   function getFilteredProducts() {
     // Return products currently visible in the list for the selected category
     const category = state.selectedCategory;
     if (!state.products || !Array.isArray(state.products)) return [];
     if (category === 'all') return [];

     return state.products.filter(p => p.category === category);
   }
   ```

4. Add a verification function to check if save was successful by refetching:
   (This is called internally after save to confirm persistence)
   ```javascript
   async function verifyProductOrder(category, expectedOrder) {
     try {
       await fetchInfo();

       const products = state.products.filter(p => p.category === category);
       const actualOrder = products.map(p => p.id);

       // Compare first few items to verify order changed
       const matches = expectedOrder.slice(0, 3).every((id, index) =>
         actualOrder[index] === id
       );

       if (!matches) {
         console.warn('[Reorder] Order verification mismatch', {
           expected: expectedOrder.slice(0, 3),
           actual: actualOrder.slice(0, 3)
         });
       }

       return matches;
     } catch (error) {
       console.error('[Reorder] Order verification failed:', error);
       return false;
     }
   }
   ```

5. Add debug logging for development to trace reorder flow:
   ```javascript
   // Add at top of file after API configuration
   const DEBUG_REORDER = !IS_PRODUCTION;

   function logReorder(action, data = {}) {
     if (!DEBUG_REORDER) return;
     console.log(`[Reorder] ${action}`, data);
   }
   ```
   Use throughout reorder functions:
   - In enterReorderMode: `logReorder('Enter mode', { category, productCount: products.length });`
   - In saveProductOrder: `logReorder('Save', { category, productCount: productIds.length });`
   - In exitReorderMode: `logReorder('Exit mode');`

6. Test customer-facing order by checking the categories page or public API:
   Add a note in comments for manual verification:
   ```javascript
   // VERIFY: After saving reorder, check customer-facing page
   // Products should appear in new order on /categories/{category}.html
   // Backend query uses: .sort({ displayOrder: 1 })
   ```
  </action>
  <verify>
1. Try to reorder a category with only 1 product - should show info toast
2. Reorder products and save
3. Open customer-facing categories page (or call /productsByCategory API)
4. Verify products appear in the new order
5. Check DevTools console for [Reorder] debug logs in development
  </verify>
  <done>Edge cases handled (empty, single product), customer-facing order reflects admin changes via displayOrder sort, debug logging available in development.</done>
</task>

</tasks>

<verification>
1. Save workflow complete:
   - Loading overlay appears during save
   - Buttons disabled while saving
   - Success toast on complete
   - Error toast on failure with message
2. 409 conflict handling:
   - Shows "updated by another admin" toast
   - Auto-refreshes product list
   - Exits reorder mode
3. beforeunload warning:
   - Browser warns when closing tab with unsaved changes
   - Internal navigation (sidebar) prompts confirm dialog
4. Customer order verification:
   - Saved order persists after page refresh
   - Customer-facing pages show new order
5. Edge cases:
   - Single product category shows info toast
   - Empty category shows error toast
   - Debug logging works in development
</verification>

<success_criteria>
- Full save lifecycle works (loading -> API call -> success/error)
- 409 conflict auto-refreshes without losing context
- Navigation protection prevents accidental data loss
- Customer-facing product order matches admin-defined order
- All requirements ORDER-06 through ORDER-09 satisfied
</success_criteria>

<output>
After completion, create `.planning/phases/06-frontend-product-reordering/06-03-SUMMARY.md`
</output>

---
phase: 06-frontend-product-reordering
plan: 02
type: execute
wave: 2
depends_on: ["06-01"]
files_modified:
  - admin/BisliView.js
autonomous: true

must_haves:
  truths:
    - "Admin can drag product rows to new positions using drag handles"
    - "Visual feedback shows drag state (ghost preview, drop zones)"
    - "Admin can undo last drag operation"
    - "Admin can redo undone operation"
    - "Multiple undo/redo operations work correctly (stack-based)"
  artifacts:
    - path: "admin/BisliView.js"
      provides: "SortableJS integration and command pattern undo/redo"
      contains: "MoveCommand"
  key_links:
    - from: "admin/BisliView.js"
      to: "SortableJS"
      via: "Sortable.create with handle option"
      pattern: "Sortable\\.create"
    - from: "SortableJS onEnd"
      to: "undoStack"
      via: "MoveCommand push"
      pattern: "undoStack\\.push"
---

<objective>
Implement drag-and-drop product reordering with SortableJS and full undo/redo capability using command pattern.

Purpose: This is the core interaction - admins drag products to new positions with immediate visual feedback, and can undo/redo mistakes before committing. Uses SortableJS (already installed) with handle mode for precise control.

Output: Working drag-and-drop within product list, undo/redo stack, visual feedback during drag.
</objective>

<execution_context>
@C:\Users\pagis\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\pagis\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/06-frontend-product-reordering/06-CONTEXT.md
@.planning/phases/06-frontend-product-reordering/06-RESEARCH.md
@.planning/phases/06-frontend-product-reordering/06-01-SUMMARY.md

@admin/BisliView.js
@frontend/css/variables.css
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement command pattern for undo/redo</name>
  <files>admin/BisliView.js</files>
  <action>
1. Add MoveCommand class after the state object and toast functions:
   ```javascript
   // Command pattern for undo/redo (per RESEARCH.md)
   class MoveCommand {
     constructor(fromIndex, toIndex, productId) {
       this.fromIndex = fromIndex;
       this.toIndex = toIndex;
       this.productId = productId;
     }

     execute(productList) {
       const item = productList.splice(this.fromIndex, 1)[0];
       productList.splice(this.toIndex, 0, item);
     }

     undo(productList) {
       const item = productList.splice(this.toIndex, 1)[0];
       productList.splice(this.fromIndex, 0, item);
     }
   }
   ```

2. Add UndoManager class:
   ```javascript
   class UndoManager {
     constructor(initialOrder) {
       this.productOrder = [...initialOrder]; // Array of product IDs in current order
       this.undoStack = [];
       this.redoStack = [];
     }

     execute(command) {
       command.execute(this.productOrder);
       this.undoStack.push(command);
       this.redoStack = []; // Clear redo on new action
     }

     undo() {
       if (this.undoStack.length === 0) return false;
       const command = this.undoStack.pop();
       command.undo(this.productOrder);
       this.redoStack.push(command);
       return true;
     }

     redo() {
       if (this.redoStack.length === 0) return false;
       const command = this.redoStack.pop();
       command.execute(this.productOrder);
       this.undoStack.push(command);
       return true;
     }

     canUndo() { return this.undoStack.length > 0; }
     canRedo() { return this.redoStack.length > 0; }
     hasChanges() { return this.undoStack.length > 0; }

     getCurrentOrder() { return [...this.productOrder]; }
   }
   ```

3. Add undoManager to state object:
   ```javascript
   undoManager: null,
   ```

4. Update enterReorderMode() to initialize UndoManager:
   ```javascript
   // After setting originalProductOrder
   const productIds = products.map(p => p.id);
   state.undoManager = new UndoManager(productIds);
   ```

5. Update exitReorderMode() to clean up:
   ```javascript
   state.undoManager = null;
   ```

6. Update updateReorderButtonStates() to use undoManager:
   ```javascript
   function updateReorderButtonStates(disabled = false) {
     const undoBtn = document.getElementById('undoBtn');
     const redoBtn = document.getElementById('redoBtn');
     const saveBtn = document.getElementById('saveReorderBtn');
     const cancelBtn = document.getElementById('cancelReorderBtn');

     if (disabled) {
       [undoBtn, redoBtn, saveBtn, cancelBtn].forEach(btn => {
         if (btn) btn.disabled = true;
       });
       return;
     }

     if (undoBtn) undoBtn.disabled = !state.undoManager?.canUndo();
     if (redoBtn) redoBtn.disabled = !state.undoManager?.canRedo();
     if (saveBtn) saveBtn.disabled = !state.undoManager?.hasChanges();
     if (cancelBtn) cancelBtn.disabled = false;
   }
   ```
  </action>
  <verify>
1. Open browser DevTools console
2. Enter reorder mode on a category
3. Type: `state.undoManager` - should show UndoManager instance with empty stacks
4. Type: `state.undoManager.canUndo()` - should return false
5. Type: `state.undoManager.canRedo()` - should return false
  </verify>
  <done>MoveCommand and UndoManager classes implemented, state tracks undo manager instance, button states derive from undo manager.</done>
</task>

<task type="auto">
  <name>Task 2: Integrate SortableJS with drag handles</name>
  <files>admin/BisliView.js</files>
  <action>
1. Import SortableJS at top of BisliView.js. Since admin is vanilla JS without bundler, add to index.html:
   ```html
   <script src="https://cdn.jsdelivr.net/npm/sortablejs@1.15.6/Sortable.min.js"></script>
   ```
   (Add before BisliView.js script tag)

2. Update enterReorderMode() to initialize SortableJS after showing drag handles:
   ```javascript
   // Initialize SortableJS
   const productList = document.querySelector('.listproduct-allproducts');
   if (productList) {
     state.sortableInstance = Sortable.create(productList, {
       handle: '.drag-handle',
       animation: 150,
       delay: 50,
       delayOnTouchOnly: true,
       ghostClass: 'sortable-ghost',
       chosenClass: 'sortable-chosen',
       dragClass: 'sortable-drag',
       forceFallback: false,
       onStart: function(evt) {
         // Add class to body for additional styling if needed
         document.body.classList.add('dragging-active');
       },
       onEnd: function(evt) {
         document.body.classList.remove('dragging-active');

         if (evt.oldIndex === evt.newIndex) return; // No change

         // Get product ID from the moved element
         const movedElement = evt.item;
         const productId = movedElement.querySelector('.edit-btn')?.dataset.productId;

         // Create and execute command
         const command = new MoveCommand(evt.oldIndex, evt.newIndex, productId);
         state.undoManager.execute(command);

         // Update button states
         updateReorderButtonStates();

         console.log(`[Reorder] Moved from ${evt.oldIndex} to ${evt.newIndex}`, {
           productId,
           canUndo: state.undoManager.canUndo(),
           stackSize: state.undoManager.undoStack.length
         });
       }
     });
   }
   ```

3. Add undo and redo button handlers in loadProductsPage():
   ```javascript
   const undoBtn = document.getElementById('undoBtn');
   if (undoBtn) {
     undoBtn.addEventListener('click', handleUndo);
   }

   const redoBtn = document.getElementById('redoBtn');
   if (redoBtn) {
     redoBtn.addEventListener('click', handleRedo);
   }
   ```

4. Implement handleUndo and handleRedo functions:
   ```javascript
   function handleUndo() {
     if (!state.undoManager || !state.undoManager.canUndo()) return;

     state.undoManager.undo();
     rerenderProductList();
     updateReorderButtonStates();
     showInfoToast('Undid last change');
   }

   function handleRedo() {
     if (!state.undoManager || !state.undoManager.canRedo()) return;

     state.undoManager.redo();
     rerenderProductList();
     updateReorderButtonStates();
     showInfoToast('Redid change');
   }
   ```

5. Implement rerenderProductList() to sync DOM with undoManager order:
   ```javascript
   function rerenderProductList() {
     if (!state.undoManager) return;

     const productList = document.querySelector('.listproduct-allproducts');
     if (!productList) return;

     const currentOrder = state.undoManager.getCurrentOrder();
     const rows = Array.from(productList.querySelectorAll('.listproduct-format'));

     // Create map of productId -> row element
     const rowMap = new Map();
     rows.forEach(row => {
       const editBtn = row.querySelector('.edit-btn');
       if (editBtn) {
         rowMap.set(editBtn.dataset.productId, row);
       }
     });

     // Reorder rows in DOM according to undoManager order
     currentOrder.forEach(productId => {
       const row = rowMap.get(productId);
       if (row) {
         productList.appendChild(row);
       }
     });

     // Reinitialize SortableJS with new order
     if (state.sortableInstance) {
       state.sortableInstance.destroy();
     }

     state.sortableInstance = Sortable.create(productList, {
       handle: '.drag-handle',
       animation: 150,
       delay: 50,
       delayOnTouchOnly: true,
       ghostClass: 'sortable-ghost',
       chosenClass: 'sortable-chosen',
       dragClass: 'sortable-drag',
       onEnd: function(evt) {
         if (evt.oldIndex === evt.newIndex) return;
         const movedElement = evt.item;
         const productId = movedElement.querySelector('.edit-btn')?.dataset.productId;
         const command = new MoveCommand(evt.oldIndex, evt.newIndex, productId);
         state.undoManager.execute(command);
         updateReorderButtonStates();
       }
     });
   }
   ```
  </action>
  <verify>
1. Open admin, Products List, select category
2. Click 'Reorder Products'
3. Drag a product by its grip handle to a new position
4. Verify: Product moves with animation, ghost preview visible
5. Verify: Undo button becomes enabled after drag
6. Click Undo - product returns to original position
7. Verify: Redo button becomes enabled
8. Click Redo - product moves back to new position
9. Drag multiple products, click Undo multiple times - each undo reverses one drag
  </verify>
  <done>SortableJS initialized with handle mode, drag operations create MoveCommands, undo/redo fully functional with DOM re-rendering.</done>
</task>

<task type="auto">
  <name>Task 3: Handle edge cases and keyboard shortcuts</name>
  <files>admin/BisliView.js</files>
  <action>
1. Add keyboard shortcuts for undo/redo (Ctrl+Z / Ctrl+Y):
   ```javascript
   function handleReorderKeyboard(e) {
     if (!state.isReorderMode) return;

     // Ctrl+Z or Cmd+Z for undo
     if ((e.ctrlKey || e.metaKey) && e.key === 'z' && !e.shiftKey) {
       e.preventDefault();
       handleUndo();
     }

     // Ctrl+Y or Cmd+Shift+Z for redo
     if ((e.ctrlKey || e.metaKey) && (e.key === 'y' || (e.key === 'z' && e.shiftKey))) {
       e.preventDefault();
       handleRedo();
     }

     // Escape to cancel
     if (e.key === 'Escape') {
       const cancelBtn = document.getElementById('cancelReorderBtn');
       if (cancelBtn) cancelBtn.click();
     }
   }
   ```

2. Update enterReorderMode() to add keyboard listener:
   ```javascript
   document.addEventListener('keydown', handleReorderKeyboard);
   ```

3. Update exitReorderMode() to remove keyboard listener:
   ```javascript
   document.removeEventListener('keydown', handleReorderKeyboard);
   ```

4. Ensure drag handles are keyboard accessible (for future enhancement):
   ```javascript
   // Add tabindex to drag handles for accessibility
   document.querySelectorAll('.drag-handle').forEach((el, index) => {
     el.setAttribute('tabindex', '0');
     el.setAttribute('role', 'button');
     el.setAttribute('aria-label', `Drag to reorder product ${index + 1}`);
   });
   ```

5. Add safeguard in cancel handler to properly reset order:
   Update the cancel button click handler in loadProductsPage():
   ```javascript
   const cancelReorderBtn = document.getElementById('cancelReorderBtn');
   if (cancelReorderBtn) {
     cancelReorderBtn.addEventListener('click', () => {
       if (state.undoManager && state.undoManager.hasChanges()) {
         if (!confirm('Discard all changes and exit reorder mode?')) return;
       }

       // Destroy sortable before reloading
       if (state.sortableInstance) {
         state.sortableInstance.destroy();
         state.sortableInstance = null;
       }

       exitReorderMode();

       // Reload products to restore original order from server
       fetchInfo();
     });
   }
   ```

6. Add safeguard when entering reorder mode while search is active:
   ```javascript
   // In enterReorderMode(), before proceeding:
   const searchInput = document.getElementById('productSearch');
   if (searchInput && searchInput.value.trim()) {
     showErrorToast('Clear search filter before reordering');
     return;
   }
   ```
  </action>
  <verify>
1. Enter reorder mode, drag a product
2. Press Ctrl+Z (or Cmd+Z on Mac) - product should undo
3. Press Ctrl+Y (or Cmd+Shift+Z) - product should redo
4. Press Escape - should prompt to cancel (if changes exist)
5. With search active, try to enter reorder mode - should show error toast
6. Click Cancel with unsaved changes - confirm dialog should appear
  </verify>
  <done>Keyboard shortcuts work (Ctrl+Z/Y, Escape), search filter blocks reorder mode, cancel properly confirms and reloads original order.</done>
</task>

</tasks>

<verification>
1. SortableJS loads from CDN without errors
2. Drag handles work - only grip icon initiates drag, not entire row
3. Ghost preview visible during drag (semi-transparent)
4. Undo reverses last drag, can be called multiple times
5. Redo re-applies undone drags
6. Ctrl+Z / Ctrl+Y keyboard shortcuts work
7. Escape key prompts to cancel
8. Cannot enter reorder mode with search active
9. Cancel with changes prompts for confirmation
10. After cancel, products reload in original order
</verification>

<success_criteria>
- Drag-and-drop works with handle-only mode
- Visual feedback (ghost, chosen, drag classes) applied correctly
- Full undo/redo stack with unlimited depth
- Keyboard shortcuts functional
- Edge cases handled (search filter, cancel confirmation)
- No memory leaks (SortableJS destroyed on exit)
</success_criteria>

<output>
After completion, create `.planning/phases/06-frontend-product-reordering/06-02-SUMMARY.md`
</output>

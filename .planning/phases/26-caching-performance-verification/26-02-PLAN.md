---
phase: 26-caching-performance-verification
plan: 02
type: execute
wave: 2
depends_on: ["26-01"]
files_modified:
  - backend/cache/invalidation.js
  - backend/index.js
  - backend/jobs/exchangeRateJob.js
autonomous: true

must_haves:
  truths:
    - "All SSR routes use cache middleware to serve cached pages and store rendered HTML"
    - "Product create/update/delete operations invalidate the product page, its category page, and the home page in both languages"
    - "Exchange rate updates invalidate all cached pages since prices change globally"
    - "Cache is skipped in test environment so existing tests are unaffected"
  artifacts:
    - path: "backend/cache/invalidation.js"
      provides: "Cache invalidation functions for product CRUD and exchange rate updates"
      exports: ["invalidateProduct", "invalidateCategory", "invalidateAll"]
    - path: "backend/index.js"
      provides: "SSR routes wrapped with cacheMiddleware, product endpoints call invalidation"
    - path: "backend/jobs/exchangeRateJob.js"
      provides: "Exchange rate job calls invalidateAll after price recalculation"
  key_links:
    - from: "backend/index.js"
      to: "backend/middleware/cacheMiddleware.js"
      via: "require and apply to SSR routes"
      pattern: "cacheMiddleware"
    - from: "backend/index.js"
      to: "backend/cache/invalidation.js"
      via: "require and call after product CRUD"
      pattern: "invalidateProduct|invalidateAll"
    - from: "backend/jobs/exchangeRateJob.js"
      to: "backend/cache/invalidation.js"
      via: "require and call after rate update"
      pattern: "invalidateAll"
---

<objective>
Wire cache middleware into all SSR routes, create cache invalidation utilities, and integrate invalidation into product CRUD endpoints and the exchange rate job.

Purpose: Cached pages serve fast, and content updates automatically clear stale cache entries so visitors always see current data.
Output: All SSR routes cached, product changes trigger targeted invalidation, exchange rate updates flush all cached pages.
</objective>

<execution_context>
@C:/Users/pagis/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/pagis/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/26-caching-performance-verification/26-RESEARCH.md
@.planning/phases/26-caching-performance-verification/26-01-SUMMARY.md
@backend/index.js
@backend/routes/ssr.js
@backend/routes/ssrDynamic.js
@backend/jobs/exchangeRateJob.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create cache invalidation module and apply cache middleware to SSR routes</name>
  <files>backend/cache/invalidation.js, backend/index.js</files>
  <action>
1. Create `backend/cache/invalidation.js`:
   - Import `pageCache` from `./pageCache`
   - Implement `invalidateCategory(categorySlug)`:
     - Delete keys for both languages: `/${lang}/${categorySlug}:${lang}:${currency}` for en/USD and he/ILS
     - Also delete home page keys: `/en:en:USD` and `/he:he:ILS` (home shows categories)
     - Log: `console.log('Cache invalidated for category:', categorySlug)`
   - Implement `invalidateProduct(productSlug, categorySlug)`:
     - Delete product detail keys: `/en/product/${productSlug}:en:USD` and `/he/product/${productSlug}:he:ILS`
     - Call `invalidateCategory(categorySlug)` if categorySlug provided (product page links from category)
     - Log: `console.log('Cache invalidated for product:', productSlug)`
   - Implement `invalidateAll()`:
     - Call `pageCache.flushAll()`
     - Log: `console.log('All page cache invalidated')`
   - Export `{ invalidateProduct, invalidateCategory, invalidateAll }`

2. In `backend/index.js`, add cache middleware to all SSR routes:
   - Add imports at top (near other route imports):
     ```javascript
     const { cacheMiddleware } = require('./middleware/cacheMiddleware');
     ```
   - Modify each SSR route to include `cacheMiddleware()` BETWEEN `languageMiddleware` and the route handler. The existing routes look like:
     ```javascript
     app.get('/:lang(en|he)', languageMiddleware, renderHomePage);
     ```
     Change to:
     ```javascript
     app.get('/:lang(en|he)', languageMiddleware, cacheMiddleware(), renderHomePage);
     ```
   - Apply to ALL SSR routes (approximately lines 1189-1204):
     - `/:lang(en|he)` (home)
     - `/:lang(en|he)/about`
     - `/:lang(en|he)/contact`
     - `/:lang(en|he)/workshop`
     - `/:lang(en|he)/policies`
     - `/:lang(en|he)/:category(necklaces|...)`
     - `/:lang(en|he)/product/:slug`
     - `/:lang(en|he)/cart`

3. In `backend/index.js`, add cache invalidation to product CRUD endpoints:
   - Import invalidation: `const { invalidateProduct, invalidateAll } = require('./cache/invalidation');`
   - The `ssrDynamic.js` file has `DB_TO_URL_CATEGORY` mapping. For the invalidation calls in index.js, you need to map database category values to URL slugs. Import it: `const { DB_TO_URL_CATEGORY } = require('./routes/ssrDynamic');` (you may need to add this export to ssrDynamic.js if not already exported)
   - After successful product save in `/addproduct` endpoint: call `invalidateProduct(product.slug, DB_TO_URL_CATEGORY[product.category])`
   - After successful product update in PUT `/products/:id`: call `invalidateProduct(product.slug, DB_TO_URL_CATEGORY[product.category])`
   - After successful product delete in DELETE `/products/:id`: call `invalidateProduct(slug, DB_TO_URL_CATEGORY[category])` (capture slug and category before deletion)

   IMPORTANT: Only add the invalidation calls AFTER the existing success response logic. Do NOT modify the existing response handling. Just add the invalidation call right before or after the success `res.status(200).json(...)` call. If the product was just saved/updated, use `product.slug` and `product.category`. If deleted, capture them before the deletion.

   NOTE: If DB_TO_URL_CATEGORY is not already exported from ssrDynamic.js, add it to the module.exports of that file.
  </action>
  <verify>
  - `node -e "const inv = require('./backend/cache/invalidation'); console.log(typeof inv.invalidateProduct, typeof inv.invalidateAll);"` outputs `function function`
  - `grep -n "cacheMiddleware" backend/index.js` shows cache middleware applied to all SSR routes
  - `grep -n "invalidateProduct\|invalidateAll" backend/index.js` shows invalidation calls in product endpoints
  </verify>
  <done>Cache middleware is applied to all 8 SSR routes, invalidation module exports three functions, product CRUD endpoints call invalidateProduct with correct slug and category, and DB_TO_URL_CATEGORY is accessible for mapping</done>
</task>

<task type="auto">
  <name>Task 2: Integrate cache invalidation into exchange rate job</name>
  <files>backend/jobs/exchangeRateJob.js</files>
  <action>
1. In `backend/jobs/exchangeRateJob.js`:
   - Add import at top: `const { invalidateAll } = require('../cache/invalidation');`
   - Find the section where products have been updated with new USD prices (after the bulk update or loop that recalculates prices)
   - Add `invalidateAll()` call after successful price updates
   - Add a log line: `console.log('Page cache invalidated due to exchange rate update');` (only in non-production, matching the existing `isProd` guard pattern in the file)

2. Ensure the invalidation only happens AFTER products are actually updated (not on exchange rate fetch failure or when no products changed). Look for the condition where `updatedCount > 0` or similar success indicator in the existing code.
  </action>
  <verify>
  - `grep -n "invalidateAll" backend/jobs/exchangeRateJob.js` shows the invalidation call
  - `grep -n "require.*invalidation" backend/jobs/exchangeRateJob.js` shows the import
  </verify>
  <done>Exchange rate job calls invalidateAll() after successful price recalculation, ensuring all cached pages with prices are refreshed on the next request</done>
</task>

</tasks>

<verification>
- All 8 SSR routes in index.js have cacheMiddleware() in their middleware chain
- Product create/update/delete endpoints call invalidateProduct with correct arguments
- Exchange rate job calls invalidateAll after price updates
- `cd backend && npm test` passes with zero regressions (cache is skipped in test environment)
</verification>

<success_criteria>
SSR pages are cached on first visit and served from cache on subsequent visits (verifiable via X-Cache header). Product CRUD operations and exchange rate updates invalidate the correct cache entries. Test suite passes unchanged.
</success_criteria>

<output>
After completion, create `.planning/phases/26-caching-performance-verification/26-02-SUMMARY.md`
</output>

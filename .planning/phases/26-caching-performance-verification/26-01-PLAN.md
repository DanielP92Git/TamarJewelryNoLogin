---
phase: 26-caching-performance-verification
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - backend/cache/pageCache.js
  - backend/cache/cacheKeys.js
  - backend/middleware/cacheMiddleware.js
  - backend/package.json
autonomous: true

must_haves:
  truths:
    - "node-cache is installed and configured with TTL and maxKeys limits"
    - "Cache keys distinguish between language and currency combinations"
    - "Cache middleware intercepts GET requests, serves cached HTML on hit, stores rendered HTML on miss"
    - "HTTP Cache-Control headers are set on all SSR responses with stale-while-revalidate"
    - "Admin routes, POST requests, and authenticated requests are never cached"
  artifacts:
    - path: "backend/cache/pageCache.js"
      provides: "node-cache instance with production config"
      contains: "new NodeCache"
    - path: "backend/cache/cacheKeys.js"
      provides: "Cache key generation with path:lang:currency format"
      exports: ["generateCacheKey"]
    - path: "backend/middleware/cacheMiddleware.js"
      provides: "Express middleware for SSR page caching with HTTP headers"
      exports: ["cacheMiddleware"]
  key_links:
    - from: "backend/middleware/cacheMiddleware.js"
      to: "backend/cache/pageCache.js"
      via: "require pageCache instance"
      pattern: "require.*pageCache"
    - from: "backend/middleware/cacheMiddleware.js"
      to: "backend/cache/cacheKeys.js"
      via: "require generateCacheKey"
      pattern: "require.*cacheKeys"
---

<objective>
Create the in-memory SSR page caching infrastructure using node-cache with language/currency-aware cache keys and an Express middleware that serves cached HTML on hit and stores rendered HTML on miss.

Purpose: Achieve sub-500ms TTFB for cached SSR pages and set proper HTTP cache headers for browser-level caching with stale-while-revalidate.
Output: Cache module, key generation utility, and cache middleware ready to be applied to SSR routes.
</objective>

<execution_context>
@C:/Users/pagis/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/pagis/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/26-caching-performance-verification/26-RESEARCH.md
@backend/routes/ssr.js
@backend/routes/ssrDynamic.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install node-cache and create cache module with key generation</name>
  <files>backend/package.json, backend/cache/pageCache.js, backend/cache/cacheKeys.js</files>
  <action>
1. Install node-cache in the backend directory:
   ```bash
   cd backend && npm install node-cache
   ```

2. Create `backend/cache/pageCache.js`:
   - Import node-cache: `const NodeCache = require('node-cache');`
   - Create instance with config:
     - `stdTTL: 3600` (1 hour default)
     - `checkperiod: 600` (cleanup every 10 minutes)
     - `useClones: false` (performance: we only store strings)
     - `maxKeys: 500` (prevent memory bloat, ~50MB limit)
   - In production (`process.env.NODE_ENV === 'production'`), log cache stats every hour via `setInterval` using `pageCache.getStats()` â€” log keys count, hits, misses, and hit rate percentage
   - Export `{ pageCache }`

3. Create `backend/cache/cacheKeys.js`:
   - Export `generateCacheKey(req)` function
   - Extract `urlLang` from `req.params.lang` (default to `'en'`)
   - Derive `currency` from language: `he` -> `ILS`, else `USD`
   - Normalize path: lowercase, remove trailing slashes
   - If query params exist, sort them alphabetically and append as `?key=val&key2=val2`
   - Return format: `"normalizedPath:lang:currency"` (e.g., `/en/necklaces:en:USD`)
   - Export `{ generateCacheKey }`
  </action>
  <verify>
  - `ls backend/node_modules/node-cache` confirms installation
  - `node -e "const {pageCache} = require('./backend/cache/pageCache'); console.log(pageCache.getStats());"` runs without error
  - `node -e "const {generateCacheKey} = require('./backend/cache/cacheKeys'); console.log(generateCacheKey({path: '/en/necklaces', params: {lang: 'en'}, query: {}}));"` outputs `/en/necklaces:en:USD`
  </verify>
  <done>node-cache installed, pageCache instance created with TTL/maxKeys config, generateCacheKey produces correct composite keys for different language/currency combinations</done>
</task>

<task type="auto">
  <name>Task 2: Create cache middleware with HTTP cache headers</name>
  <files>backend/middleware/cacheMiddleware.js</files>
  <action>
Create `backend/middleware/cacheMiddleware.js`:

1. Import `pageCache` from `../cache/pageCache` and `generateCacheKey` from `../cache/cacheKeys`

2. Export `cacheMiddleware(options)` factory function:
   - `options.ttl` (default 3600 seconds)
   - Returns Express middleware `(req, res, next)`

3. Middleware logic:
   a. **Skip conditions** (call `next()` immediately):
      - `req.method !== 'GET'`
      - `req.path.startsWith('/admin')`
      - `req.headers.authorization` exists
      - `process.env.NODE_ENV === 'test'` (skip entirely in test environment to avoid test interference)

   b. **Cache lookup:**
      - Generate key via `generateCacheKey(req)`
      - Check `pageCache.get(cacheKey)`
      - If HIT: set `X-Cache: HIT` header, set `Cache-Control: public, max-age=3600, stale-while-revalidate=86400` header, send cached body, return

   c. **Cache miss (intercept res.send):**
      - Store reference to `res.send`
      - Override `res.send` with wrapper function:
        - If `res.statusCode === 200` and `typeof body === 'string'`: store in `pageCache.set(cacheKey, body, ttl)`
        - Set `X-Cache: MISS` header
        - Set `Cache-Control: public, max-age=3600, stale-while-revalidate=86400` header
        - Call original `res.send.call(this, body)`
      - Call `next()`

4. Export `{ cacheMiddleware }`

Important: Use `res.send = function(body) { ... }` (not arrow function) to preserve `this` context.
  </action>
  <verify>
  - `node -e "const {cacheMiddleware} = require('./backend/middleware/cacheMiddleware'); console.log(typeof cacheMiddleware);"` outputs `function`
  - Verify the middleware skips non-GET by checking the code
  </verify>
  <done>Cache middleware exports a factory function that returns Express middleware, serves cached HTML on hit with X-Cache: HIT header, intercepts and stores 200 responses on miss with X-Cache: MISS header, sets Cache-Control with stale-while-revalidate on all responses, and skips caching for admin/auth/test/non-GET requests</done>
</task>

</tasks>

<verification>
- `backend/cache/pageCache.js` exists and creates a NodeCache instance with stdTTL=3600, maxKeys=500
- `backend/cache/cacheKeys.js` exports generateCacheKey that produces keys in `path:lang:currency` format
- `backend/middleware/cacheMiddleware.js` exports cacheMiddleware factory that returns Express middleware
- Cache middleware sets both X-Cache and Cache-Control headers
- Test environment is bypassed (NODE_ENV === 'test')
</verification>

<success_criteria>
Cache infrastructure is ready: node-cache installed, cache module configured with appropriate limits, key generation produces unique keys per language/currency combo, and middleware is ready to be applied to routes (route integration happens in plan 02).
</success_criteria>

<output>
After completion, create `.planning/phases/26-caching-performance-verification/26-01-SUMMARY.md`
</output>

---
phase: 16-security-and-middleware
plan: 03
type: execute
wave: 1
depends_on: []
files_modified:
  - backend/tests/integration/security.validation.test.js
  - backend/tests/helpers/securityVectors.js
autonomous: true

must_haves:
  truths:
    - "XSS payloads in product descriptions are sanitized or escaped"
    - "NoSQL injection operators in login fields are rejected"
    - "Valid Hebrew/Unicode names pass validation"
    - "Input validation returns user-friendly error messages"
    - "Content-type validation enforces application/json"
  artifacts:
    - path: "backend/tests/integration/security.validation.test.js"
      provides: "Input validation security tests"
      min_lines: 150
      contains: "describe.*Validation|XSS|Injection"
    - path: "backend/tests/helpers/securityVectors.js"
      provides: "OWASP-based attack vectors for testing"
      min_lines: 40
      contains: "xssVectors|noSqlVectors"
  key_links:
    - from: "backend/tests/integration/security.validation.test.js"
      to: "backend/index.js"
      via: "supertest testing POST endpoints"
      pattern: "request\\(app\\).*post.*addproduct|login|signup"
---

<objective>
Test input validation to prevent XSS and NoSQL injection attacks

Purpose: Verify the application properly validates and sanitizes user input to prevent cross-site scripting (XSS) attacks and NoSQL injection. These are OWASP Top 10 vulnerabilities that could lead to data theft, account hijacking, or database manipulation.

Output: Integration test file covering SEC-08, SEC-09 requirements plus security vectors helper file with ~25 test cases
</objective>

<execution_context>
@C:\Users\pagis\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\pagis\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/16-security-and-middleware/16-CONTEXT.md
@.planning/phases/16-security-and-middleware/16-RESEARCH.md

# Test infrastructure patterns
@backend/tests/setup.js
@backend/tests/integration/auth.login.test.js
@backend/tests/helpers/factories.js

# Route handlers with validation
@backend/index.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create security vectors helper and XSS validation tests</name>
  <files>backend/tests/helpers/securityVectors.js, backend/tests/integration/security.validation.test.js</files>
  <action>
Create security test vectors helper file and XSS validation tests.

**1. Create `backend/tests/helpers/securityVectors.js`:**

```javascript
/**
 * Security Test Vectors
 *
 * OWASP-based attack payloads for security testing.
 * Sources:
 * - OWASP XSS Filter Evasion Cheat Sheet
 * - OWASP NoSQL Injection Testing Guide
 * - PortSwigger XSS Cheat Sheet
 */

// XSS vectors from OWASP XSS Filter Evasion Cheat Sheet
export const xssVectors = [
  // Basic script injection
  '<script>alert("xss")</script>',
  '<script>alert(String.fromCharCode(88,83,83))</script>',

  // Event handler injection
  '<img src=x onerror=alert(1)>',
  '<svg onload=alert(1)>',
  '<body onload=alert(1)>',

  // Attribute injection
  '"><script>alert(1)</script>',
  "' onclick='alert(1)",
  '" onfocus="alert(1)" autofocus="',

  // URL-based XSS
  "javascript:alert('XSS')",
  'javascript:/*--></title></style></textarea></script></xmp><svg/onload=\'+/"/+/onmouseover=1/+/[*/[]/+alert(1)//\'>',

  // Template injection (Angular/Vue style)
  '{{constructor.constructor("alert(1)")()}}',
  '${alert(1)}',

  // Data URL
  '<a href="data:text/html,<script>alert(1)</script>">click</a>',

  // Unicode/encoding evasion
  '<script>alert(1)</script>',  // Using \u003c \u003e
  '%3Cscript%3Ealert(1)%3C/script%3E',  // URL encoded
];

// NoSQL injection vectors for MongoDB
export const noSqlVectors = [
  // Operator injection (bypass authentication)
  { field: 'email', value: { $gt: '' } },
  { field: 'email', value: { $ne: null } },
  { field: 'email', value: { $ne: '' } },
  { field: 'password', value: { $ne: '' } },

  // Regex injection
  { field: 'email', value: { $regex: '.*' } },
  { field: 'email', value: { $regex: '^admin' } },

  // $where clause injection (if MongoDB allows it)
  { field: '$where', value: '1==1' },
  { field: '$where', value: 'this.password.length > 0' },

  // Array operators
  { field: 'email', value: { $in: ['admin@example.com'] } },
  { field: 'email', value: { $nin: [''] } },
];

// Valid Unicode inputs that should NOT be blocked
export const validUnicodeInputs = [
  'תכשיטים יפים',              // Hebrew product name
  'Sarah (שרה)',                // Mixed Hebrew/English
  'Tamar Kfir Jewelry',         // English
  'Émilie Müller',              // European diacritics
  '日本語テスト',               // Japanese
  'Test 123 @#$%',              // Common special chars
];

// Dangerous Unicode sequences that SHOULD be blocked/sanitized
export const dangerousUnicodeInputs = [
  '\u0000malicious',            // Null byte injection
  'name\u202Eevil',             // RTL override character (text direction manipulation)
  '\u200Bhidden',               // Zero-width space (invisible text)
  'a'.repeat(10001),            // Excessive length (DoS)
];

export default {
  xssVectors,
  noSqlVectors,
  validUnicodeInputs,
  dangerousUnicodeInputs,
};
```

**2. Create `backend/tests/integration/security.validation.test.js`:**

```javascript
/**
 * Input Validation Security Tests
 *
 * Tests XSS prevention and NoSQL injection protection.
 * Uses OWASP-recommended attack vectors.
 */
import { describe, it, expect, beforeAll, beforeEach, afterAll } from 'vitest';
import request from 'supertest';
import mongoose from 'mongoose';

import { createUser, createAdmin, createProduct } from '../helpers/factories.js';
import { createAuthToken } from '../helpers/authHelpers.js';
import { validateTestEnvironment } from '../helpers/envGuard.js';
import { disableNetConnect, cleanAllMocks } from '../helpers/mocks/index.js';
import { xssVectors, validUnicodeInputs } from '../helpers/securityVectors.js';
```

**XSS Test Suite (SEC-08):**

```javascript
describe('Input Validation - XSS Prevention', () => {
  let app;
  let adminToken;
  let Product;

  beforeAll(async () => {
    validateTestEnvironment();
    disableNetConnect();

    const appModule = await import('../../index.js');
    app = appModule.app;
    Product = mongoose.model('Product');

    // Create admin user for product creation tests
    const User = mongoose.model('Users');
    const adminData = createAdmin({ email: 'xss-test-admin@example.com' });
    await new User(adminData).save();
    adminToken = createAuthToken({
      id: adminData._id.toString(),
      email: adminData.email,
      userType: 'admin'
    });
  });

  beforeEach(async () => {
    cleanAllMocks();
  });

  /**
   * SEC-08: XSS sanitization in product descriptions
   * Threat: Attacker injects script tags in product description, executes in victim browser
   * Protection: Server should sanitize/escape HTML before storing
   */
  describe('Product Description XSS', () => {
    it('should sanitize or escape script tags in description', async () => {
      const productData = createProduct({
        description: '<script>alert("xss")</script>'
      });

      const response = await request(app)
        .post('/addproduct')
        .set('auth-token', adminToken)
        .send(productData);

      // Check what was stored in database
      const saved = await Product.findOne({ id: productData.id });

      if (saved) {
        // Either: script tags removed/escaped, OR no raw <script> tag
        expect(saved.description).not.toContain('<script>');
        // Document actual behavior for future reference
        console.log('Stored description:', saved.description);
      }
    });

    it.each(xssVectors.slice(0, 5))('should handle XSS vector: %s', async (xssPayload) => {
      const productData = createProduct({
        description: xssPayload
      });

      const response = await request(app)
        .post('/addproduct')
        .set('auth-token', adminToken)
        .send(productData);

      const saved = await Product.findOne({ id: productData.id });

      if (saved && saved.description) {
        // Should not contain raw executable script patterns
        expect(saved.description).not.toMatch(/<script[^>]*>/i);
        expect(saved.description).not.toMatch(/onerror\s*=/i);
        expect(saved.description).not.toMatch(/onload\s*=/i);
      }
    });
  });
});
```

**Document actual behavior:** This phase tests existing security - if XSS passes through, that's a finding to document, not a test failure. Use console.log to capture actual behavior.
  </action>
  <verify>
Run: `cd backend && npm test -- --run security.validation.test.js`
XSS tests run. Document findings (pass = sanitized, fail = vulnerability exists).
  </verify>
  <done>
Security vectors helper created. XSS validation tests created (SEC-08).
  </done>
</task>

<task type="auto">
  <name>Task 2: Add NoSQL injection and Unicode validation tests</name>
  <files>backend/tests/integration/security.validation.test.js</files>
  <action>
Add NoSQL injection and Unicode validation tests to the existing file.

**NoSQL Injection Test Suite (SEC-09):**

```javascript
import { noSqlVectors, validUnicodeInputs, dangerousUnicodeInputs } from '../helpers/securityVectors.js';

describe('Input Validation - NoSQL Injection Prevention', () => {
  let app;

  beforeAll(async () => {
    validateTestEnvironment();
    disableNetConnect();
    const appModule = await import('../../index.js');
    app = appModule.app;
  });

  /**
   * SEC-09: NoSQL operator injection in login
   * Threat: Attacker sends {$ne: null} as email to bypass authentication
   * Protection: Server should validate input types before querying
   */
  describe('Login Endpoint NoSQL Injection', () => {
    it('should reject object value for email field', async () => {
      const response = await request(app)
        .post('/login')
        .send({
          email: { $gt: '' },
          password: 'TestPassword123'
        });

      // Should reject with validation error, NOT process the query
      // If 500 returned, query may have been attempted (vulnerability)
      // If 400 returned, validation caught it (good)
      // If 200/401/404, need to check if query was sanitized
      expect([400, 401, 404]).toContain(response.status);

      // Should NOT return 500 (unhandled error = possible injection)
      expect(response.status).not.toBe(500);
    });

    it('should reject $ne operator in email field', async () => {
      const response = await request(app)
        .post('/login')
        .send({
          email: { $ne: null },
          password: 'TestPassword123'
        });

      // Document actual behavior
      console.log('$ne injection response:', response.status, response.body);

      // At minimum, should not succeed (200) unless a user exists
      if (response.status === 200) {
        // This is a vulnerability - authentication bypassed
        console.warn('WARNING: NoSQL injection may have bypassed auth');
      }
    });

    it('should reject $regex operator in email field', async () => {
      const response = await request(app)
        .post('/login')
        .send({
          email: { $regex: '.*' },
          password: 'TestPassword123'
        });

      expect([400, 401, 404]).toContain(response.status);
    });

    it('should reject $where clause', async () => {
      const response = await request(app)
        .post('/login')
        .send({
          $where: '1==1',
          email: 'test@example.com',
          password: 'test'
        });

      // Should not execute the $where clause
      expect([400, 401, 404]).toContain(response.status);
    });
  });

  describe('Signup Endpoint NoSQL Injection', () => {
    it('should reject object values in signup fields', async () => {
      const response = await request(app)
        .post('/signup')
        .send({
          email: { $gt: '' },
          password: 'TestPassword123',
          name: 'Test User'
        });

      // Should be rejected at validation, not create a user
      expect([400, 500]).toContain(response.status);

      // If somehow succeeded, verify no user created with weird email
      const User = mongoose.model('Users');
      const weirdUser = await User.findOne({ email: { $type: 'object' } });
      expect(weirdUser).toBeNull();
    });
  });
});
```

**Unicode/RTL Validation Tests:**

```javascript
describe('Unicode and RTL Character Handling', () => {
  let app;
  let adminToken;

  beforeAll(async () => {
    // Setup with admin auth...
  });

  /**
   * Positive test: Valid Hebrew names should be accepted
   * This app supports Hebrew - don't block legitimate input
   */
  describe('Valid Unicode Acceptance', () => {
    it.each(validUnicodeInputs)('should accept valid Unicode name: %s', async (name) => {
      const productData = createProduct({
        name: name,
        description: 'Test product'
      });

      const response = await request(app)
        .post('/addproduct')
        .set('auth-token', adminToken)
        .send(productData);

      // Should not reject valid Unicode
      expect([200, 201]).toContain(response.status);
    });
  });

  /**
   * Dangerous Unicode sequences that could cause issues
   */
  describe('Dangerous Unicode Rejection', () => {
    it('should handle null byte injection', async () => {
      const response = await request(app)
        .post('/addproduct')
        .set('auth-token', adminToken)
        .send(createProduct({
          name: '\u0000malicious',
          description: 'Test'
        }));

      // Document behavior - null bytes may be stripped or rejected
      console.log('Null byte response:', response.status);
    });

    it('should handle excessive length input', async () => {
      const response = await request(app)
        .post('/addproduct')
        .set('auth-token', adminToken)
        .send(createProduct({
          name: 'a'.repeat(10001),
          description: 'Test'
        }));

      // Should reject or truncate excessively long input
      expect([400, 413, 201]).toContain(response.status);
    });
  });
});
```

**Content-Type Validation Tests:**

```javascript
describe('Content-Type Validation', () => {
  let app;

  beforeAll(async () => {
    const appModule = await import('../../index.js');
    app = appModule.app;
  });

  it('should accept application/json content type', async () => {
    const response = await request(app)
      .post('/login')
      .set('Content-Type', 'application/json')
      .send({ email: 'test@example.com', password: 'test' });

    // Should be processed (even if auth fails)
    expect([400, 401, 404]).toContain(response.status);
  });

  it('should reject or handle text/plain content type', async () => {
    const response = await request(app)
      .post('/login')
      .set('Content-Type', 'text/plain')
      .send('email=test@example.com&password=test');

    // Document behavior - Express may or may not parse this
    console.log('text/plain response:', response.status);
  });
});
```

**Test count target:** 20-25 tests covering:
- XSS prevention: 8-10 tests (vectors, product descriptions)
- NoSQL injection: 6-8 tests (login, signup, operators)
- Unicode handling: 4-5 tests (valid Hebrew, dangerous sequences)
- Content-type: 2-3 tests
  </action>
  <verify>
Run: `cd backend && npm test -- --run security.validation.test.js`
All tests run. Review console output for documented behavior.
Expected: 20+ test cases, documenting actual security posture.
  </verify>
  <done>
Input validation tests complete, covering SEC-08 (XSS), SEC-09 (NoSQL injection). Unicode and content-type handling documented.
  </done>
</task>

</tasks>

<verification>
Run full input validation test suite:
```bash
cd backend && npm test -- --run security.validation.test.js
```

Expected output:
- All tests execute (some may document vulnerabilities if they exist)
- XSS vectors tested against product descriptions
- NoSQL operators tested against login/signup
- Valid Hebrew names accepted
- Dangerous Unicode sequences handled

Review security findings:
- Check console output for documented behavior
- If vulnerabilities found, they're documented for future fixing
- Tests verify current state, not ideal state

Count tests:
```bash
grep -c "it\(" backend/tests/integration/security.validation.test.js
```
Target: 20+ test cases
</verification>

<success_criteria>
- [ ] securityVectors.js helper exists with OWASP-based payloads
- [ ] security.validation.test.js exists with 20+ test cases
- [ ] SEC-08: XSS vectors tested, behavior documented
- [ ] SEC-09: NoSQL injection operators tested, behavior documented
- [ ] Valid Hebrew/Unicode names pass validation
- [ ] Dangerous Unicode sequences handled
- [ ] Content-type validation tested
- [ ] All tests execute: `npm test -- --run security.validation.test.js`
- [ ] Security posture documented (findings may exist)
</success_criteria>

<output>
After completion, create `.planning/phases/16-security-and-middleware/16-03-SUMMARY.md`
</output>

---
phase: 16-security-and-middleware
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - backend/tests/integration/security.ratelimit.test.js
autonomous: true

must_haves:
  truths:
    - "Rate limiting enforces limits on auth endpoints (/login, /signup)"
    - "Rate limiting enforces limits on payment endpoints (/orders)"
    - "Requests within rate limits are allowed through"
    - "Requests exceeding rate limits receive 429 Too Many Requests"
    - "Rate limit headers follow draft-7 standard"
  artifacts:
    - path: "backend/tests/integration/security.ratelimit.test.js"
      provides: "Rate limiting middleware integration tests"
      min_lines: 120
      contains: "describe.*Rate"
  key_links:
    - from: "backend/tests/integration/security.ratelimit.test.js"
      to: "backend/index.js"
      via: "supertest testing rate limited endpoints"
      pattern: "request\\(app\\).*post.*login|signup|orders"
---

<objective>
Test rate limiting middleware on auth and payment endpoints

Purpose: Verify the application protects against brute force attacks and abuse by enforcing request limits. Rate limiting is critical for preventing credential stuffing attacks on login, account creation abuse on signup, and payment fraud on order endpoints.

Output: Integration test file covering SEC-04, SEC-05, SEC-06, SEC-07 requirements with ~15-20 test cases
</objective>

<execution_context>
@C:\Users\pagis\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\pagis\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/16-security-and-middleware/16-CONTEXT.md
@.planning/phases/16-security-and-middleware/16-RESEARCH.md

# Test infrastructure patterns
@backend/tests/setup.js
@backend/tests/integration/auth.login.test.js

# Rate limit configuration (lines 215-247)
@backend/index.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create rate limiting tests for auth endpoints</name>
  <files>backend/tests/integration/security.ratelimit.test.js</files>
  <action>
Create `backend/tests/integration/security.ratelimit.test.js` with rate limiting tests.

**Important rate limit isolation strategy:**
Use unique X-Forwarded-For IP addresses per test to prevent rate limit state contamination between tests. Pattern:
```javascript
const uniqueIP = () => `192.168.1.${Date.now() % 255}`;
// OR for guaranteed uniqueness within a test file:
let ipCounter = 0;
const uniqueIP = () => `10.0.0.${++ipCounter}`;
```

**File structure:**
- Import vitest (describe, it, expect, beforeAll, beforeEach, afterAll)
- Import supertest (request)
- Import factories (createUser) for creating test users
- Import helpers (validateTestEnvironment, disableNetConnect, cleanAllMocks)
- Dynamic app import in beforeAll

**Codebase rate limit configuration (from index.js):**
- authRateLimiter: 20 requests per 15 minutes (env: RATE_LIMIT_AUTH_MAX)
- paymentRateLimiter: 60 requests per 15 minutes (env: RATE_LIMIT_PAYMENT_MAX)
- adminRateLimiter: 120 requests per 15 minutes (env: RATE_LIMIT_ADMIN_MAX)

**Test suites to create:**

1. **Auth Endpoint Rate Limiting (/login)** (SEC-04, SEC-06, SEC-07):

```javascript
describe('Rate Limiting - Auth Endpoints (/login)', () => {
  let app;
  let ipCounter = 0;
  const uniqueIP = () => `10.0.${Math.floor(ipCounter / 255)}.${++ipCounter % 255}`;

  beforeAll(async () => {
    // Set lower rate limit for faster testing
    process.env.RATE_LIMIT_AUTH_MAX = '5';
    // ... import app
  });

  // Tests...
});
```

Tests:
- `should allow requests within rate limit` - Send 3 requests (under limit of 5), all should NOT return 429
- `should return 429 when rate limit exceeded` - Send 6 requests (over limit of 5), verify last returns 429
- `should include rate limit headers on normal response` - Check ratelimit-limit, ratelimit-remaining, ratelimit-reset
- `should include Retry-After header on 429 response` - Verify timing information provided
- `should return proper error message on 429` - Verify response body matches configured message: { success: false, error: 'Too many requests...' }
- `should track rate limit per IP address` - Two different IPs can both make requests up to limit

2. **Auth Endpoint Rate Limiting (/signup)** (SEC-04):
- `should enforce rate limit on signup endpoint` - Similar pattern to login
- `should share rate limit between login and signup` - If they use same limiter, requests to both count together (verify codebase behavior first)

**Testing approach:**
- Set RATE_LIMIT_AUTH_MAX to a low value (e.g., 5) in beforeAll for faster tests
- Use unique X-Forwarded-For header per test to isolate rate limit state
- Sequential requests using for loop
- Check response.status for 429
- Check response.headers for rate limit headers (lowercase: 'ratelimit-limit', 'ratelimit-remaining')

**Important:** Login requests with invalid credentials return 400/401/404, but still count against rate limit. Don't confuse auth errors with rate limit errors.
  </action>
  <verify>
Run: `cd backend && npm test -- --run security.ratelimit.test.js`
Tests for auth endpoints pass. Verify rate limit triggers 429 correctly.
  </verify>
  <done>
Auth endpoint rate limiting tests complete, covering SEC-04, SEC-06 (within limit), SEC-07 (exceeding limit).
  </done>
</task>

<task type="auto">
  <name>Task 2: Add payment endpoint and header verification tests</name>
  <files>backend/tests/integration/security.ratelimit.test.js</files>
  <action>
Add payment endpoint rate limiting tests to the existing file.

**Additional test suites:**

3. **Payment Endpoint Rate Limiting (/orders)** (SEC-05):

```javascript
describe('Rate Limiting - Payment Endpoints (/orders)', () => {
  beforeAll(async () => {
    process.env.RATE_LIMIT_PAYMENT_MAX = '5';
    // ... import app
  });
  // Tests...
});
```

Tests:
- `should allow requests within payment rate limit` - Send 3 requests, verify not 429
- `should return 429 when payment rate limit exceeded` - Send 6 requests, verify 429
- `should use separate rate limit from auth endpoints` - Different IP counter, confirm limits are independent

**Note:** Payment endpoints require authentication and valid cart data. For rate limit testing, we just need to hit the endpoint - the rate limiter runs before request validation. Send minimal request body:
```javascript
const response = await request(app)
  .post('/orders')
  .set('X-Forwarded-For', uniqueIP())
  .send({});  // Empty body - will fail validation but rate limit still counts
```

4. **Rate Limit Header Verification (draft-7 standard):**
- `should use draft-7 standard header format (lowercase)` - Verify 'ratelimit-limit' not 'RateLimit-Limit'
- `should include ratelimit-limit header with correct value` - Match RATE_LIMIT_*_MAX
- `should include ratelimit-remaining header` - Decrements with each request
- `should include ratelimit-reset header` - Contains reset timestamp

5. **Admin Endpoint Rate Limiting (optional, if time permits):**
- `should enforce rate limit on admin endpoints` - /addproduct, /upload, etc.
- Admin endpoints require auth - use createAuthToken helper if testing

**429 Response Validation:**
```javascript
it('should return proper 429 response body', async () => {
  const ip = uniqueIP();
  const limit = 5;

  // Exhaust limit
  for (let i = 0; i < limit; i++) {
    await request(app)
      .post('/login')
      .set('X-Forwarded-For', ip)
      .send({ email: 'test@example.com', password: 'wrong' });
  }

  // Next request should be rate limited
  const response = await request(app)
    .post('/login')
    .set('X-Forwarded-For', ip)
    .send({ email: 'test@example.com', password: 'wrong' });

  expect(response.status).toBe(429);
  expect(response.body).toEqual({
    success: false,
    error: 'Too many requests, please try again later.'
  });
});
```

**Threat model comments:** Add JSDoc comments:
```javascript
/**
 * SEC-04: Auth endpoint rate limiting
 * Threat: Credential stuffing attacks that try thousands of password combinations
 * Protection: 20 requests per 15 minutes per IP prevents automated attacks
 */
```

**Test count target:** 15-18 tests covering:
- Auth endpoints (login, signup): 6-8 tests
- Payment endpoints (orders): 4-5 tests
- Header verification: 4-5 tests
  </action>
  <verify>
Run: `cd backend && npm test -- --run security.ratelimit.test.js`
All tests pass (auth + payment + headers).
Expected: 15-18 test cases total.
  </verify>
  <done>
Rate limiting tests complete, covering SEC-04, SEC-05, SEC-06, SEC-07. Header format and error responses verified.
  </done>
</task>

</tasks>

<verification>
Run full rate limiting test suite:
```bash
cd backend && npm test -- --run security.ratelimit.test.js
```

Expected output:
- All tests pass
- Coverage includes auth endpoints, payment endpoints, headers

Verify 429 responses:
- Tests confirm rate limit triggers correctly
- Error message matches configured value
- Headers follow draft-7 standard

Count tests:
```bash
grep -c "it\(" backend/tests/integration/security.ratelimit.test.js
```
Target: 15+ test cases
</verification>

<success_criteria>
- [ ] security.ratelimit.test.js exists with 15+ test cases
- [ ] SEC-04: Tests verify rate limits on auth endpoints (/login, /signup)
- [ ] SEC-05: Tests verify rate limits on payment endpoints (/orders)
- [ ] SEC-06: Tests verify requests within limits are allowed
- [ ] SEC-07: Tests verify requests exceeding limits get 429
- [ ] Rate limit headers verified (ratelimit-limit, ratelimit-remaining, ratelimit-reset)
- [ ] 429 response body matches configured message
- [ ] All tests pass: `npm test -- --run security.ratelimit.test.js`
</success_criteria>

<output>
After completion, create `.planning/phases/16-security-and-middleware/16-02-SUMMARY.md`
</output>

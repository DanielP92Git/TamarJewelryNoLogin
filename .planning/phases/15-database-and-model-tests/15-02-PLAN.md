---
phase: 15-database-and-model-tests
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - backend/tests/models/user.test.js
  - backend/tests/models/settings.test.js
autonomous: true

must_haves:
  truths:
    - "User model creates users with hashed passwords and correct defaults"
    - "User model validates email format using regex match and enforces email uniqueness"
    - "User model rejects duplicate emails including race conditions"
    - "User model accepts valid userType values and stores default 'user' when unspecified"
    - "Settings model implements singleton pattern via getSettings() static method"
    - "Settings model updates exchange rate fields and preserves other settings"
    - "Settings getSettings() handles concurrent calls without creating duplicate documents"
  artifacts:
    - path: "backend/tests/models/user.test.js"
      provides: "User model tests covering DATA-10 through DATA-13"
      min_lines: 100
    - path: "backend/tests/models/settings.test.js"
      provides: "Settings model tests covering DATA-14 and DATA-15"
      min_lines: 60
  key_links:
    - from: "backend/tests/models/user.test.js"
      to: "backend/models/User.js"
      via: "Direct Mongoose model import for validation and uniqueness testing"
      pattern: "require.*models/User|import.*User"
    - from: "backend/tests/models/settings.test.js"
      to: "backend/models/Settings.js"
      via: "Direct Mongoose model import for singleton and CRUD testing"
      pattern: "require.*models/Settings|import.*Settings"
---

<objective>
Write User model and Settings model tests covering validation, uniqueness constraints, password hashing, and singleton behavior.

Purpose: Verify the User Mongoose model enforces email uniqueness, validates email format, stores hashed passwords, and handles userType correctly. Verify the Settings model singleton pattern (getSettings static method) and exchange rate field updates. Covers DATA-10 (user creation with hashing), DATA-11 (email format validation), DATA-12 (email uniqueness), DATA-13 (userType validation), DATA-14 (settings read), DATA-15 (settings update).

Output: `backend/tests/models/user.test.js` + `backend/tests/models/settings.test.js` test files
</objective>

<execution_context>
@C:\Users\pagis\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\pagis\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/15-database-and-model-tests/15-CONTEXT.md
@.planning/phases/15-database-and-model-tests/15-RESEARCH.md

Key backend references:
@backend/models/User.js
@backend/models/Settings.js
@backend/tests/setup.js
@backend/tests/helpers/factories.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create User model tests</name>
  <files>backend/tests/models/user.test.js</files>
  <action>
Create `backend/tests/models/user.test.js` with direct Mongoose model tests for the User model. Do NOT test through HTTP endpoints.

Import pattern:
```javascript
import { describe, it, expect, beforeAll } from 'vitest';
import mongoose from 'mongoose';
import bcrypt from 'bcrypt';
```

Import the User model using dynamic import (CommonJS module):
```javascript
let User;
beforeAll(async () => {
  User = (await import('../../models/User.js')).default;
});
```

**Test groups to implement:**

1. **User Creation - Valid Data (DATA-10):**
   - `should create user with valid email and password` - Create with `{ email: 'test@example.com', password: 'SecurePass123' }`. Verify `_id` defined, email saved correctly, userType defaults to 'user'.
   - `should store password as-is (no pre-save hash hook in schema)` - Create user with password 'plaintext'. Verify `user.password === 'plaintext'`. IMPORTANT: The User schema does NOT have a pre-save hook for password hashing. Hashing is done in the signup endpoint logic, not in the model. Phase 11 already tested hashing in the signup endpoint. This test documents actual model behavior.
   - `should set default userType to 'user'` - Create user without specifying userType. Verify it defaults to 'user'.
   - `should set default Date to current date` - Create user, verify Date field is defined and is a Date object close to now (within 5 seconds).
   - `should create user with name and cartData` - Create with all optional fields. Verify all fields persisted.

2. **Email Format Validation (DATA-11):**
   The User schema has a regex match validator for email. Test the regex pattern:
   - `should accept valid email formats` - Test: 'user@example.com', 'user+tag@example.com', 'first.last@domain.org'. All should save.
   - `should reject email without @ symbol` - Try 'notanemail'. Expect validation error.
   - `should reject email without domain` - Try 'user@'. Expect validation error.
   - `should reject email without local part` - Try '@example.com'. Expect validation error.
   - `should reject empty string email` - Try email: ''. Expect validation error (required + match).
   Note: The regex pattern is lowercase-only: `[a-z0-9...]`. Test if uppercase emails like 'User@Example.com' pass or fail. Document actual behavior - this is important for understanding case sensitivity.

3. **Email Uniqueness (DATA-12):**
   - `should reject duplicate email` - Create user with email 'dup@example.com', try creating second with same email. Expect MongoDB duplicate key error (code 11000).
   - `should treat emails as case-sensitive (no lowercase transform)` - Create user with 'test@example.com'. Try creating with 'Test@example.com'. Since the schema has NO `lowercase: true` and the regex only matches lowercase, the uppercase version will likely fail the regex validator first. Test and document actual behavior.
   - `should prevent race condition duplicates` - Use `Promise.allSettled()` with 3 concurrent creates of same email. Verify only 1 succeeded. Check final DB count is 1.

4. **UserType Behavior (DATA-13):**
   Note: The User schema has NO enum constraint on userType - it's a plain String with default 'user'.
   - `should accept userType 'admin'` - Create user with userType: 'admin'. Verify saves.
   - `should accept userType 'user'` - Create user with userType: 'user'. Verify saves.
   - `should accept any string as userType (no enum validator)` - Create user with userType: 'moderator'. Verify it saves (documenting actual schema behavior - no enum restriction).
   - `should default to 'user' when userType not specified` - Verify default value.

5. **User CRUD Operations:**
   - `should find user by email` - Create user, `User.findOne({ email })`. Verify found.
   - `should update user email` - Create user, update email, verify change persisted.
   - `should delete user by ID` - Create user, `User.deleteOne({ _id })`, verify deleted.
   - `should update cartData` - Create user, update cartData with product items. Verify cartData persisted with correct structure.

**Important implementation notes:**
- User model is registered as 'Users' (plural) via `mongoose.model('Users', UserSchema)`. If importing via `import`, the model reference is already registered.
- The User model does NOT hash passwords in a pre-save hook. Hashing happens at the endpoint level. Do NOT expect hashed passwords from `.create()`.
- Each test starts fresh (afterEach clears DB via setup.js).
- Use unique emails per test to avoid conflicts (use counter pattern or different string literals).
  </action>
  <verify>
Run: `cd backend && npx vitest run tests/models/user.test.js --reporter=verbose`

Expected: All tests pass. Minimum 18 tests covering:
- 5 creation/defaults tests (DATA-10)
- 5 email format tests (DATA-11)
- 3 email uniqueness tests (DATA-12)
- 4 userType tests (DATA-13)
- 4 CRUD operation tests
  </verify>
  <done>User model test file has 18+ passing tests covering DATA-10 through DATA-13 including creation defaults, email regex validation, email uniqueness with race conditions, userType behavior documentation, and basic CRUD operations.</done>
</task>

<task type="auto">
  <name>Task 2: Create Settings model tests</name>
  <files>backend/tests/models/settings.test.js</files>
  <action>
Create `backend/tests/models/settings.test.js` with direct Mongoose model tests for the Settings model singleton pattern and CRUD operations.

Import pattern:
```javascript
import { describe, it, expect, beforeAll } from 'vitest';
import mongoose from 'mongoose';
```

Import the Settings model using dynamic import:
```javascript
let Settings;
beforeAll(async () => {
  Settings = (await import('../../models/Settings.js')).default;
});
```

**Test groups to implement:**

1. **Settings Read - getSettings Singleton (DATA-14):**
   - `should create settings document when none exists` - Call `Settings.getSettings()`. Verify returns a document with `_id`, `global_discount_percentage` defaults to 0, `discount_active` defaults to false.
   - `should return existing settings on subsequent calls` - Call `getSettings()` twice. Verify both return the same `_id` (same document).
   - `should return settings with default exchange rate fields` - Call `getSettings()`. Verify `usd_ils_rate` is null (default), `exchange_rate_last_updated` is null, `exchange_rate_source` is null.
   - `should return settings with default discount fields` - Verify `discount_label` defaults to 'Discount'.
   - `should handle concurrent getSettings calls without duplicates` - Use `Promise.all()` with 5 concurrent `Settings.getSettings()` calls. Verify `Settings.countDocuments()` returns 1 after all resolve.

2. **Settings Update (DATA-15):**
   - `should update exchange rate fields` - Call `getSettings()` to create, then update with `Settings.updateOne({}, { $set: { usd_ils_rate: 3.75, exchange_rate_last_updated: new Date(), exchange_rate_source: 'test-api' } })`. Find settings again, verify all three fields updated.
   - `should update discount fields` - Update `global_discount_percentage: 15, discount_active: true, discount_label: 'Holiday Sale'`. Verify all updated.
   - `should preserve unmodified fields on partial update` - Create settings, update only `usd_ils_rate`. Verify `global_discount_percentage` and `discount_active` remain at their previous values.
   - `should update using findOneAndUpdate` - Use `Settings.findOneAndUpdate({}, { usd_ils_rate: 4.0 }, { new: true })`. Verify returned document has updated rate.
   - `should update updatedAt field` - Get settings, note updatedAt. Update a field. Get settings again, verify updatedAt changed (or is at least defined).

3. **Settings Creation Constraints:**
   - `should create settings with custom initial values` - Use `Settings.create({ global_discount_percentage: 10, usd_ils_rate: 3.5 })`. Verify values saved.
   - `should allow direct create of settings document` - Verify `Settings.create({})` works with all defaults.

**Important implementation notes:**
- The Settings model uses `mongoose.models.Settings || mongoose.model('Settings', SettingsSchema)` pattern.
- The `getSettings()` static method uses `findOne()` then `create({})` if null. This is NOT atomic - race conditions may create duplicates, but in practice the first one wins and subsequent `findOne()` calls find it.
- The concurrent test with `Promise.all()` may reveal race condition behavior - if duplicates are created, the test should document this. Use `Promise.allSettled()` if `Promise.all()` throws, then check final count.
- The global afterEach clears all collections, so each test starts fresh.
  </action>
  <verify>
Run: `cd backend && npx vitest run tests/models/settings.test.js --reporter=verbose`

Expected: All tests pass. Minimum 12 tests covering:
- 5 getSettings singleton tests (DATA-14)
- 5 update tests (DATA-15)
- 2 creation tests

Also run full suite to check no regressions:
`cd backend && npx vitest run --reporter=verbose`
  </verify>
  <done>Settings model test file has 12+ passing tests covering DATA-14 and DATA-15 including singleton getSettings pattern, concurrent access behavior, exchange rate updates, discount field updates, and partial update preservation. All existing tests remain passing.</done>
</task>

</tasks>

<verification>
1. Run full test suite: `cd backend && npx vitest run --reporter=verbose`
2. Confirm all existing tests still pass (no regressions from 296 test baseline)
3. Confirm user.test.js has 18+ passing tests
4. Confirm settings.test.js has 12+ passing tests
5. Verify User model coverage: creation, email validation, uniqueness, userType, CRUD
6. Verify Settings model coverage: singleton pattern, exchange rate updates, discount updates
7. Verify tests use in-memory MongoDB only (no production database access)
</verification>

<success_criteria>
- user.test.js exists in backend/tests/models/ directory with 18+ passing tests
- settings.test.js exists in backend/tests/models/ directory with 12+ passing tests
- User creation with defaults verified (userType 'user', no password hashing in model)
- Email format validation verified (regex match accepts/rejects correctly)
- Email uniqueness enforced (duplicate rejection, race condition handling)
- UserType behavior documented (no enum constraint, accepts any string)
- Settings singleton pattern verified (getSettings creates or returns existing)
- Settings concurrent access verified (no duplicate documents)
- Exchange rate and discount field updates verified
- Partial update preservation verified
- All existing 296 tests remain passing
</success_criteria>

<output>
After completion, create `.planning/phases/15-database-and-model-tests/15-02-SUMMARY.md`
</output>

---
phase: 07-image-array-migration
plan: 03
type: execute
wave: 3
depends_on: ["07-02"]
files_modified:
  - backend/index.js
autonomous: true

must_haves:
  truths:
    - "API responses include images array for all product endpoints"
    - "API responses still include mainImage and smallImages for backwards compatibility"
    - "If product has images array, mainImage/smallImages are derived from it"
    - "If product only has old fields, they pass through unchanged"
    - "New products created via API use images array as primary storage"
  artifacts:
    - path: "backend/index.js"
      provides: "Updated normalizeProductForClient with images array handling"
      contains: "images"
  key_links:
    - from: "backend/index.js:normalizeProductForClient"
      to: "API product responses"
      via: "function call in route handlers"
      pattern: "normalizeProductForClient"
---

<objective>
Update backend API to handle images array while maintaining backwards compatibility for un-updated frontends.

Purpose: Ensure API responses work with both old (mainImage/smallImages) and new (images array) data formats. Frontend can continue using old field names during transition, while new code can use images array directly.

Output: API returns both formats - images array AND derived mainImage/smallImages - for seamless transition.
</objective>

<execution_context>
@C:\Users\pagis\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\pagis\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-image-array-migration/07-02-SUMMARY.md
@backend/index.js
@backend/models/Product.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Update normalizeProductForClient for images array</name>
  <files>backend/index.js</files>
  <action>
Update the normalizeProductForClient function in backend/index.js to handle both old and new image formats.

Find the normalizeProductForClient function (around line 347-476) and modify it to:

1. **Check for images array first** (per CONTEXT.md: "new array wins" conflict resolution):
   ```javascript
   // If product has unified images array, derive mainImage/smallImages from it
   if (Array.isArray(obj.images) && obj.images.length > 0) {
     // Normalize images array URLs
     obj.images = obj.images.map(img => {
       if (!img || typeof img !== 'object') return img;
       return {
         desktop: toAbsoluteApiUrl(img.desktop),
         mobile: toAbsoluteApiUrl(img.mobile),
         publicDesktop: toAbsoluteApiUrl(img.publicDesktop),
         publicMobile: toAbsoluteApiUrl(img.publicMobile),
         // Omit local fields from response
       };
     });

     // Derive mainImage from first element for backwards compatibility
     if (!obj.mainImage || typeof obj.mainImage !== 'object') {
       obj.mainImage = obj.images[0];
     }

     // Derive smallImages from remaining elements for backwards compatibility
     if (!Array.isArray(obj.smallImages) || obj.smallImages.length === 0) {
       obj.smallImages = obj.images.slice(1);
     }
   }
   ```

2. **Keep existing mainImage/smallImages normalization** as fallback for products not yet migrated (shouldn't exist after 07-02, but defensive).

3. **Add images array to existing image fallback logic**:
   - If images array exists, use images[0] for image/publicImage/directImageUrl fallbacks
   - Apply localAssetExistsForUrl checks to images array elements

4. **Ensure omitLocalImageFields also handles images array**:
   Update the omitLocalImageFields function to remove desktopLocal/mobileLocal from images array elements:
   ```javascript
   if (Array.isArray(obj.images)) {
     obj.images = obj.images.map(img => {
       if (!img || typeof img !== 'object') return img;
       const copy = { ...img };
       delete copy.desktopLocal;
       delete copy.mobileLocal;
       return copy;
     });
   }
   ```

The key principle: API always returns BOTH formats. New clients use images array, old clients use mainImage/smallImages. No breaking changes.
  </action>
  <verify>
Test API response includes both formats:
```bash
cd backend
npm run devStart &
sleep 3
curl -s http://localhost:4000/allproducts | node -e "const data = JSON.parse(require('fs').readFileSync(0, 'utf8')); const p = data[0]; console.log('Has images:', Array.isArray(p.images)); console.log('Has mainImage:', !!p.mainImage); console.log('Has smallImages:', Array.isArray(p.smallImages)); console.log('Images count:', p.images?.length); console.log('mainImage matches images[0]:', JSON.stringify(p.mainImage?.desktop) === JSON.stringify(p.images?.[0]?.desktop));"
```
  </verify>
  <done>
normalizeProductForClient updated to handle images array. API responses include both images array AND derived mainImage/smallImages for backwards compatibility.
  </done>
</task>

<task type="auto">
  <name>Task 2: Update addproduct endpoint for new products</name>
  <files>backend/index.js</files>
  <action>
Update the /addproduct endpoint to store images in the unified array format.

Find the /addproduct endpoint (around line 1609) and modify the product creation to:

1. **Build images array from uploaded files**:
   After processing mainImage upload, instead of storing separately:
   ```javascript
   // Build unified images array
   const images = [];

   // Main image becomes first element
   if (mainImageData && Object.keys(mainImageData).length > 0) {
     images.push(mainImageData);
   }

   // Gallery images become subsequent elements
   if (Array.isArray(processedSmallImages) && processedSmallImages.length > 0) {
     images.push(...processedSmallImages);
   }
   ```

2. **Store in both old and new format** during transition:
   ```javascript
   const productData = {
     // ... other fields ...
     images: images,  // New unified array
     mainImage: images[0] || null,  // For backwards compatibility
     smallImages: images.slice(1) || [],  // For backwards compatibility
   };
   ```

This ensures new products are created with images array as primary, but old fields are also populated for any code that might still read them directly.

Note: The exact implementation depends on how mainImageData and processedSmallImages are built in the current code. Preserve existing image processing logic, just change where the results are stored.
  </action>
  <verify>
Create a test product via admin (or curl if auth allows) and verify:
- Product has images array
- images[0] matches mainImage
- images.slice(1) matches smallImages
  </verify>
  <done>
/addproduct endpoint updated to store images in unified array format while maintaining backwards compatibility fields.
  </done>
</task>

<task type="auto">
  <name>Task 3: Update updateproduct endpoint for existing products</name>
  <files>backend/index.js</files>
  <action>
Update the /updateproduct/:id endpoint (around line 1955) to maintain images array when editing products.

Similar to addproduct:

1. When processing uploaded images, build images array
2. Store in both old and new format
3. When NO new images uploaded, preserve existing images array from database

Key consideration: If admin uploads new main image only, update images[0] but keep images[1..n] from existing data.

```javascript
// When building update data:
const existingProduct = await Product.findById(id);

// Start with existing images or empty array
let images = Array.isArray(existingProduct?.images) ? [...existingProduct.images] : [];

// If new main image uploaded, replace images[0]
if (newMainImageData && Object.keys(newMainImageData).length > 0) {
  if (images.length > 0) {
    images[0] = newMainImageData;
  } else {
    images.push(newMainImageData);
  }
}

// If new gallery images uploaded, replace images[1..n]
if (Array.isArray(newSmallImages) && newSmallImages.length > 0) {
  images = [images[0], ...newSmallImages].filter(Boolean);
}

// Update both formats
updateData.images = images;
updateData.mainImage = images[0] || null;
updateData.smallImages = images.slice(1) || [];
```

Also handle the legacy /updateproduct endpoint (without :id, around line 2335) with similar logic.
  </action>
  <verify>
After updating a product via admin:
1. Check database shows images array updated
2. Check mainImage matches images[0]
3. Check smallImages matches images.slice(1)
  </verify>
  <done>
/updateproduct endpoints updated to maintain images array when editing products. Both new and legacy endpoints handle the unified array format.
  </done>
</task>

</tasks>

<verification>
Phase 7 Plan 03 complete when:
- [ ] normalizeProductForClient handles images array
- [ ] API responses include both images array AND mainImage/smallImages
- [ ] /addproduct stores images in unified array
- [ ] /updateproduct/:id maintains images array on edit
- [ ] Backwards compatibility verified - old frontend code still works
- [ ] New products created have correct images array structure
</verification>

<success_criteria>
- API returns both formats in all product responses
- New products use images array as primary storage
- Existing products edited maintain images array
- No breaking changes to existing frontend
</success_criteria>

<output>
After completion, create `.planning/phases/07-image-array-migration/07-03-SUMMARY.md`
</output>

---
phase: 20-page-view-tests
plan: 03
type: execute
wave: 1
depends_on: []
files_modified:
  - frontend/tests/views/checkout.test.js
  - frontend/tests/views/home.test.js
  - frontend/tests/views/contact.test.js
autonomous: true

must_haves:
  truths:
    - "Checkout view renders Stripe checkout button"
    - "Checkout view displays order summary with correct totals matching cart"
    - "Stripe checkout button triggers POST to /create-checkout-session"
    - "Home page view renders category name elements for each jewelry category"
    - "Contact form rejects empty required fields"
    - "Contact form blocks honeypot-triggered submissions (silently succeeds)"
    - "Contact form blocks submissions made too quickly (under 3 seconds)"
    - "Contact form accepts valid submissions with all fields filled"
  artifacts:
    - path: "frontend/tests/views/checkout.test.js"
      provides: "Checkout payment method and order summary tests"
      min_lines: 60
    - path: "frontend/tests/views/home.test.js"
      provides: "Home page category rendering tests"
      min_lines: 40
    - path: "frontend/tests/views/contact.test.js"
      provides: "Contact form validation and anti-spam tests"
      min_lines: 100
  key_links:
    - from: "frontend/tests/views/checkout.test.js"
      to: "frontend/js/Views/cartView.js"
      via: "CartView._addHandlerCheckout triggers Stripe session"
      pattern: "create-checkout-session"
    - from: "frontend/tests/views/home.test.js"
      to: "frontend/js/Views/homePageView.js"
      via: "HomePageView.setCategoriesLng renders category names"
      pattern: "setCategoriesLng|category-name"
    - from: "frontend/tests/views/contact.test.js"
      to: "frontend/js/Views/contactMeView.js"
      via: "ContactMeView.sendEmail and _validateNotBot"
      pattern: "sendEmail|_validateNotBot|_validateContent"
---

<objective>
Test checkout payment flow, home page category rendering, and contact form validation including anti-spam measures.

Purpose: Verify PAGE-09, PAGE-10 (checkout), PAGE-12 (home page), and PAGE-13 (contact form) requirements -- completing coverage of all page-specific views.
Output: `frontend/tests/views/checkout.test.js`, `frontend/tests/views/home.test.js`, `frontend/tests/views/contact.test.js`
</objective>

<execution_context>
@C:\Users\pagis\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\pagis\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/20-page-view-tests/20-CONTEXT.md
@.planning/phases/20-page-view-tests/20-RESEARCH.md

Source files to test:
@frontend/js/Views/cartView.js (checkout is part of CartView)
@frontend/js/Views/homePageView.js
@frontend/js/Views/contactMeView.js
@frontend/js/View.js
@frontend/js/model.js

Existing test infrastructure:
@frontend/tests/setup.js
@frontend/tests/helpers/dom.js
@frontend/tests/helpers/factories.js
@frontend/vitest.config.js

Established patterns:
@frontend/tests/view/language.test.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create checkout view payment and order summary tests</name>
  <files>frontend/tests/views/checkout.test.js</files>
  <action>
Create `frontend/tests/views/checkout.test.js` covering PAGE-09 and PAGE-10 requirements.

**Architecture understanding:**
- Checkout is NOT a separate view -- it's part of CartView. The checkout button (`#stripe-checkout-btn`) lives in the cart page.
- `CartView._addHandlerCheckout(data)` receives the cart items array and adds a click listener to the checkout button.
- On click, it maps cart items to always use USD prices, then POSTs to `${this._host}/create-checkout-session` with `{ items, currency: '$' }`.
- On success (`{ url }`), it sets `window.location = url` to redirect to Stripe.
- The order summary is rendered by `CartView._renderSummary(cartNum, lng)` which calls `_generateSummaryMarkup()`.
- Summary shows: Subtotal, optional Discount line, Shipping ("Calculated at checkout"), and Total.

**Testing strategy:**
Since CartView is a singleton with DOM-dependent constructor (same issue as Plan 01), use the same approach: render DOM fixture before dynamic import.

Focus tests on:
1. Checkout button presence and visibility
2. Order summary rendering with correct totals
3. Stripe checkout session creation (mock fetch, verify request body)

**Test structure:**

1. **Payment Method Selection (PAGE-09)**
   - "should render Stripe checkout button" -- Verify `#stripe-checkout-btn` exists and is not hidden
   - "should show 'Check Me Out With:' label" -- Verify `.check-me-out` contains text

2. **Order Summary with Totals (PAGE-10)**
   - "should display subtotal matching sum of cart item prices" -- 2 items, verify subtotal = sum
   - "should show 'Calculated at checkout' for shipping" -- Verify shipping label text
   - "should display discount line when global discount is active" -- Mock getGlobalDiscount to return active, verify discount line appears
   - "should hide order summary when cart is empty" -- cartNum=0, verify summary container has 'remove' class

3. **Stripe Checkout Trigger**
   - "should POST to /create-checkout-session when checkout button clicked" -- Mock fetch, click button, verify fetch called with correct URL and method
   - "should send items with USD prices to Stripe regardless of display currency" -- Even if currency is ILS, verify request body has `currency: '$'`
   - "should redirect to Stripe URL on successful response" -- Mock fetch to return `{ url: 'https://checkout.stripe.com/xxx' }`, verify `window.location` set

**DOM fixture:** Same cart fixture as Plan 01 plus PayPal container:
```
<header></header>
<div class="menu"></div>
<div data-purpose="header-utilities"></div>
<div class="footer"></div>
<div class="cart-items-container"></div>
<div class="cart-empty"></div>
<h2 class="cart-title"></h2>
<h3 class="summary-title"></h3>
<div class="added-items"></div>
<div class="summary-details"></div>
<button id="stripe-checkout-btn">Checkout</button>
<button class="delete-all"></button>
<div class="check-me-out">Check Me Out With:</div>
<div class="summary"></div>
<div id="paypal"></div>
```

**Mocking:**
- Mock `model.cart` with test items that have both usdPrice and ilsPrice
- Mock `model.checkCartNumber` to return cart length
- Mock `model.getGlobalDiscount` -- return `{ active: false, percentage: 0 }` for no-discount tests, `{ active: true, percentage: 10 }` for discount tests
- Mock `global.fetch` with `vi.fn()` for Stripe checkout session
- Mock `process.env.API_URL` as 'http://localhost:4000'

Run `npx vitest run tests/views/checkout.test.js` from frontend directory to verify.
  </action>
  <verify>
Run `cd frontend && npx vitest run tests/views/checkout.test.js` -- all tests pass with 0 failures.
Verify at least 7 test cases covering payment methods, summary totals, and checkout trigger.
  </verify>
  <done>
Checkout tests prove:
- PAGE-09: Checkout view renders payment method selection (Stripe button)
- PAGE-10: Checkout view displays order summary with correct totals
- Stripe checkout session creation verified with correct request body
- USD prices always sent to Stripe regardless of display currency
  </done>
</task>

<task type="auto">
  <name>Task 2: Create home page and contact form tests</name>
  <files>frontend/tests/views/home.test.js, frontend/tests/views/contact.test.js</files>
  <action>
Create two test files: `frontend/tests/views/home.test.js` (PAGE-12) and `frontend/tests/views/contact.test.js` (PAGE-13).

---

**HOME PAGE TESTS (PAGE-12):**

**Architecture understanding:**
- HomePageView is a singleton exported as `export default new HomePageView()`.
- Its constructor extends View (no heavy constructor logic like CategoriesView).
- `setCategoriesLng(lng)` renders category names into specific DOM elements.
- Category elements: `.category-name_necklaces`, `.category-name_crochet-necklaces`, `.category-name_hoops`, `.category-name_bracelets`, `.category-name_dangle`, `.category-name_unisex`
- `setHomeLanguage(lng)` calls `setCategoriesLng(lng)` and `handleFooterMarkup(lng)`.
- There are no "featured products" fetched from an API. The home page has static category links, not dynamic product cards. So PAGE-12 ("Home page view renders featured products") maps to: home page renders category sections that users browse.

**DOM fixture for home page:**
```
<header></header>
<div class="menu"></div>
<div data-purpose="header-utilities"></div>
<div class="footer"></div>
<div class="category-name category-name_necklaces">Necklaces</div>
<div class="category-name category-name_crochet-necklaces">Crochet Necklaces</div>
<div class="category-name category-name_hoops">Hoop Earrings</div>
<div class="category-name category-name_bracelets">Bracelets</div>
<div class="category-name category-name_dangle">Dangle Earrings</div>
<div class="category-name category-name_unisex">Unisex Jewelry</div>
```

**Test structure:**

1. **Home Page Category Rendering (PAGE-12)**
   - "should render all jewelry category names in English" -- Call setCategoriesLng('eng'), verify all 6 category names in English
   - "should render all jewelry category names in Hebrew" -- Call setCategoriesLng('heb'), verify Hebrew text for each category
   - "should set Hebrew font family when language is Hebrew" -- Verify style.fontFamily includes 'Rubik'
   - "should set page-specific language via setPageSpecificLanguage" -- Call setPageSpecificLanguage('eng', 0), verify categories updated

---

**CONTACT FORM TESTS (PAGE-13):**

**Architecture understanding:**
- ContactMeView is a singleton exported as `export default new ContactMeView()`.
- `_submitBtn` is set in constructor via `document.getElementById('submit')` -- DOM must exist at import time.
- `sendEmail()` is the main submission handler. It:
  1. Reads form field values (name, lastname, contact-email, message)
  2. Runs `_validateNotBot()` -- checks honeypot and timing
  3. Runs `_validateContent()` -- checks URLs, name format, message length, spam patterns, email format
  4. If all pass, calls `emailjs.send()` with params
  5. On success, clears form and alerts 'Message Sent Successfully!'
- `_validateNotBot()` returns `{ valid, reason }` -- checks:
  - Honeypot: `#website` field must be empty
  - Timing: `Date.now() - _formLoadTime >= 3000` (3 seconds minimum)
- `_validateContent(name, lastname, email, message)` returns `{ valid, reason }` -- checks:
  - URL count <= 2
  - Name matches `/^[a-zA-Z\u0590-\u05FF\s'-]{2,}$/`
  - Message text >= 10 chars after removing URLs/whitespace
  - No spam keywords
  - Email format valid

**DOM fixture for contact form:**
```
<header></header>
<div class="menu"></div>
<div data-purpose="header-utilities"></div>
<div class="footer"></div>
<div class="contact-form">
  <input type="text" id="name" name="name" required />
  <input type="text" id="lastname" name="lastname" required />
  <input type="email" id="contact-email" name="email" required />
  <textarea id="message" name="message" required></textarea>
  <div style="position: absolute; left: -9999px;" aria-hidden="true">
    <input type="text" name="website" id="website" tabindex="-1" autocomplete="off" />
  </div>
  <input type="hidden" name="form_loaded_at" id="formLoadedAt" />
  <button type="submit" id="submit">Send Message</button>
</div>
<div class="contact-title">Get in Touch</div>
<div class="contact-subtitle">Have a question?</div>
```

**Test structure:**

1. **Required Field Validation (PAGE-13)**
   - "should reject submission when name is empty" -- Set name='', call sendEmail, verify alert says check input (content validation catches it via name pattern)
   - "should reject submission when email is empty" -- Empty email, verify content validation rejects
   - "should reject submission when message is empty" -- Empty message, verify content validation rejects (message_too_short)
   - "should accept submission when all required fields are valid" -- Fill all fields with valid data, set _formLoadTime to 5 seconds ago, mock emailjs.send to resolve, verify success alert

2. **Anti-Spam: Honeypot**
   - "should silently block submission when honeypot field is filled" -- Fill honeypot (#website) field, call sendEmail, verify form is cleared and fake success alert shown (to confuse bots)
   - "should allow submission when honeypot field is empty" -- Normal flow with empty honeypot

3. **Anti-Spam: Timing**
   - "should block submission when form filled too quickly (under 3 seconds)" -- Set _formLoadTime to Date.now() (just loaded), call sendEmail, verify blocked with fake success
   - "should allow submission when form filled after 3+ seconds" -- Set _formLoadTime to Date.now() - 5000, verify not blocked

4. **Content Validation**
   - "should reject message with too many URLs" -- Message with 3+ URLs, verify rejection
   - "should reject names with invalid characters (numbers only)" -- name='12345', verify rejection
   - "should reject message that is too short" -- message='hi', verify rejection with specific error
   - "should reject spam keywords in message" -- Message containing 'buy now free money', verify rejection
   - "should reject invalid email format" -- email='notanemail', verify rejection

5. **Successful Submission**
   - "should call emailjs.send with correct parameters" -- Mock emailjs.send, fill valid form, verify called with service ID, template ID, and params
   - "should clear form fields after successful submission" -- Verify all inputs are empty after send

**Mocking:**
- Mock `emailjs` module: `vi.mock('@emailjs/browser', () => ({ default: { send: vi.fn().mockResolvedValue({}) }, EmailJSResponseStatus: class {} }))`
- Mock `window.alert` with `vi.fn()`
- For ContactMeView singleton import timing: render DOM fixture first, then dynamic import

**Important notes:**
- ContactMeView._submitBtn is set in constructor. Handle this by either:
  (a) Using dynamic import after render
  (b) Reassigning _submitBtn after render
- _validateNotBot and _validateContent are private methods called inside sendEmail. Test through sendEmail for integration, or access directly for unit tests.
- The fake success alert for spam ("Message Sent Successfully!") is intentionally identical to real success to confuse bots.

Run both test files:
- `npx vitest run tests/views/home.test.js`
- `npx vitest run tests/views/contact.test.js`
  </action>
  <verify>
Run `cd frontend && npx vitest run tests/views/home.test.js tests/views/contact.test.js` -- all tests pass with 0 failures.
Verify: home.test.js has 4+ tests, contact.test.js has 10+ tests.
  </verify>
  <done>
Home page and contact form tests prove:
- PAGE-12: Home page renders category sections for browsing
- PAGE-13: Contact form validates required fields, blocks spam via honeypot and timing, validates content quality, submits successfully when all checks pass
  </done>
</task>

</tasks>

<verification>
Run full frontend test suite: `cd frontend && npx vitest run`
- All existing tests still pass (no regressions)
- New checkout.test.js, home.test.js, and contact.test.js all pass
- Test count increases by 20+ tests
</verification>

<success_criteria>
- frontend/tests/views/checkout.test.js exists with 7+ passing tests
- frontend/tests/views/home.test.js exists with 4+ passing tests
- frontend/tests/views/contact.test.js exists with 10+ passing tests
- PAGE-09, PAGE-10 (checkout) requirements verified
- PAGE-12 (home page) requirement verified
- PAGE-13 (contact form) requirement verified with anti-spam coverage
- No regressions in existing test suite
</success_criteria>

<output>
After completion, create `.planning/phases/20-page-view-tests/20-03-SUMMARY.md`
</output>

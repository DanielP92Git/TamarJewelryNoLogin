---
phase: 10-test-infrastructure-foundation
plan: 05
type: execute
wave: 2
depends_on: ["10-01"]
files_modified:
  - backend/tests/helpers/fixtures/products.js
  - backend/tests/helpers/fixtures/users.js
  - backend/tests/helpers/fixtures/index.js
  - backend/tests/helpers/factories.js
  - backend/tests/setup.js
autonomous: true

must_haves:
  truths:
    - "Test fixtures provide consistent mock data for products and users"
    - "Factory functions create unique test data on each call"
    - "Test data is cleaned up after each test (no pollution)"
    - "afterEach hooks automatically clear test collections"
  artifacts:
    - path: "backend/tests/helpers/fixtures/products.js"
      provides: "Product test data fixtures"
      exports: ["mockProduct", "mockProductWithImages", "mockProductCategory"]
    - path: "backend/tests/helpers/fixtures/users.js"
      provides: "User test data fixtures"
      exports: ["mockUser", "mockAdmin", "mockUserCredentials"]
    - path: "backend/tests/helpers/factories.js"
      provides: "Factory functions for dynamic test data"
      exports: ["createProduct", "createUser", "createOrder"]
  key_links:
    - from: "backend/tests/setup.js"
      to: "backend/tests/helpers/db.js"
      via: "clearDatabase in afterEach"
      pattern: "afterEach.*clearDatabase"
---

<objective>
Create test data fixtures and factory functions for consistent, isolated test data.

Purpose: Provide reusable mock data and factory functions that create test-specific data, ensuring each test has predictable data and no test pollution between runs.
Output: Fixture modules with mock products/users and factory functions that generate unique test data.
</objective>

<execution_context>
@C:\Users\pagis\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\pagis\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/10-test-infrastructure-foundation/10-CONTEXT.md

# Data models for fixture structure
@backend/models/Product.js
@backend/models/User.js

# Existing test setup
@backend/tests/setup.js
@backend/tests/helpers/db.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create product and user fixtures</name>
  <files>
    backend/tests/helpers/fixtures/products.js
    backend/tests/helpers/fixtures/users.js
    backend/tests/helpers/fixtures/index.js
  </files>
  <action>
Create backend/tests/helpers/fixtures/products.js:

```javascript
/**
 * Product test data fixtures.
 * Static mock data for consistent test scenarios.
 */
import mongoose from 'mongoose';

/**
 * Basic product fixture matching Product schema.
 */
export const mockProduct = {
  _id: new mongoose.Types.ObjectId('507f1f77bcf86cd799439011'),
  name: 'Test Silver Necklace',
  description: 'A beautiful handmade silver necklace for testing',
  usdPrice: 75,
  ilsPrice: 277.50,
  category: 'necklaces',
  images: ['products/test-necklace-1.jpg'],
  quantity: 10,
  sku: 'TEST-NECK-001',
  displayOrder: 0,
  createdAt: new Date('2024-01-15T10:00:00Z'),
  updatedAt: new Date('2024-01-15T10:00:00Z')
};

/**
 * Product with multiple images (gallery).
 */
export const mockProductWithImages = {
  ...mockProduct,
  _id: new mongoose.Types.ObjectId('507f1f77bcf86cd799439012'),
  name: 'Test Gold Bracelet',
  sku: 'TEST-BRAC-001',
  category: 'bracelets',
  usdPrice: 120,
  ilsPrice: 444,
  images: [
    'products/test-bracelet-1.jpg',
    'products/test-bracelet-2.jpg',
    'products/test-bracelet-3.jpg'
  ]
};

/**
 * Products grouped by category for testing category views.
 */
export const mockProductsByCategory = {
  necklaces: [mockProduct],
  bracelets: [mockProductWithImages],
  earrings: [{
    _id: new mongoose.Types.ObjectId('507f1f77bcf86cd799439013'),
    name: 'Test Pearl Earrings',
    description: 'Elegant pearl earrings',
    usdPrice: 45,
    ilsPrice: 166.50,
    category: 'earrings',
    images: ['products/test-earrings-1.jpg'],
    quantity: 5,
    sku: 'TEST-EAR-001',
    displayOrder: 0
  }]
};

/**
 * Product without SKU (legacy data scenario).
 */
export const mockProductNoSku = {
  ...mockProduct,
  _id: new mongoose.Types.ObjectId('507f1f77bcf86cd799439014'),
  name: 'Legacy Product',
  sku: undefined
};

/**
 * All product categories used in the application.
 */
export const productCategories = [
  'necklaces',
  'bracelets',
  'earrings',
  'rings',
  'anklets',
  'sets'
];
```

Create backend/tests/helpers/fixtures/users.js:

```javascript
/**
 * User test data fixtures.
 * Static mock data for auth and user-related tests.
 */
import mongoose from 'mongoose';
import bcrypt from 'bcrypt';

/**
 * Basic user fixture (regular customer).
 */
export const mockUser = {
  _id: new mongoose.Types.ObjectId('507f1f77bcf86cd799439101'),
  email: 'testuser@example.com',
  password: '$2b$10$abcdefghijklmnopqrstuv', // hashed 'TestPassword123'
  userType: 'user',
  firstName: 'Test',
  lastName: 'User',
  cart: [],
  createdAt: new Date('2024-01-01T00:00:00Z')
};

/**
 * Admin user fixture.
 */
export const mockAdmin = {
  _id: new mongoose.Types.ObjectId('507f1f77bcf86cd799439102'),
  email: 'admin@example.com',
  password: '$2b$10$abcdefghijklmnopqrstuv', // hashed 'AdminPassword123'
  userType: 'admin',
  firstName: 'Admin',
  lastName: 'User',
  cart: [],
  createdAt: new Date('2024-01-01T00:00:00Z')
};

/**
 * Raw credentials for testing login.
 * Use these with the hashed passwords above.
 */
export const mockUserCredentials = {
  email: 'testuser@example.com',
  password: 'TestPassword123'
};

export const mockAdminCredentials = {
  email: 'admin@example.com',
  password: 'AdminPassword123'
};

/**
 * User with items in cart.
 */
export const mockUserWithCart = {
  ...mockUser,
  _id: new mongoose.Types.ObjectId('507f1f77bcf86cd799439103'),
  email: 'cartuser@example.com',
  cart: [
    {
      productId: '507f1f77bcf86cd799439011',
      quantity: 2,
      price: 75
    }
  ]
};

/**
 * Invalid/malformed user for negative testing.
 */
export const mockInvalidUser = {
  email: 'not-an-email',
  password: '123', // too short
  userType: 'invalid-type'
};
```

Create backend/tests/helpers/fixtures/index.js:

```javascript
/**
 * Central export for all test fixtures.
 */
export * from './products.js';
export * from './users.js';
```
  </action>
  <verify>
Files exist at:
- backend/tests/helpers/fixtures/products.js
- backend/tests/helpers/fixtures/users.js
- backend/tests/helpers/fixtures/index.js

Syntax check:
```bash
cd backend
node -e "require('./tests/helpers/fixtures/index.js')"
```
  </verify>
  <done>
Product fixtures created:
- Basic product, product with images, products by category, legacy product without SKU

User fixtures created:
- Regular user, admin user, credentials for login tests, user with cart items
  </done>
</task>

<task type="auto">
  <name>Task 2: Create factory functions for dynamic test data</name>
  <files>backend/tests/helpers/factories.js</files>
  <action>
Create backend/tests/helpers/factories.js:

```javascript
/**
 * Factory functions for creating unique test data.
 * Use factories when you need fresh, unique data for each test.
 * Use fixtures when you need consistent, predictable data.
 */
import mongoose from 'mongoose';
import bcrypt from 'bcrypt';

// Counter for generating unique values
let counter = 0;

/**
 * Reset counter (call in beforeEach for predictable sequences).
 */
export function resetFactoryCounter() {
  counter = 0;
}

/**
 * Create a unique product with optional overrides.
 * @param {Object} overrides - Properties to override defaults
 * @returns {Object} Product data (not saved to DB)
 */
export function createProduct(overrides = {}) {
  counter++;
  return {
    _id: new mongoose.Types.ObjectId(),
    name: `Test Product ${counter}`,
    description: `Description for test product ${counter}`,
    usdPrice: 50 + counter,
    ilsPrice: (50 + counter) * 3.7,
    category: 'necklaces',
    images: [`products/test-product-${counter}.jpg`],
    quantity: 10,
    sku: `TEST-${counter.toString().padStart(4, '0')}`,
    displayOrder: counter - 1,
    createdAt: new Date(),
    updatedAt: new Date(),
    ...overrides
  };
}

/**
 * Create a unique user with optional overrides.
 * @param {Object} overrides - Properties to override defaults
 * @returns {Object} User data (not saved to DB)
 */
export function createUser(overrides = {}) {
  counter++;
  return {
    _id: new mongoose.Types.ObjectId(),
    email: `testuser${counter}@example.com`,
    password: bcrypt.hashSync('TestPassword123', 10),
    userType: 'user',
    firstName: `Test${counter}`,
    lastName: 'User',
    cart: [],
    createdAt: new Date(),
    ...overrides
  };
}

/**
 * Create an admin user with optional overrides.
 * @param {Object} overrides - Properties to override defaults
 * @returns {Object} Admin user data
 */
export function createAdmin(overrides = {}) {
  return createUser({
    userType: 'admin',
    email: `admin${counter}@example.com`,
    ...overrides
  });
}

/**
 * Create a cart item for a product.
 * @param {string} productId - Product ObjectId as string
 * @param {number} quantity - Quantity in cart
 * @param {number} price - Price at time of adding
 */
export function createCartItem(productId, quantity = 1, price = 50) {
  return {
    productId,
    quantity,
    price
  };
}

/**
 * Create multiple products in batch.
 * @param {number} count - Number of products to create
 * @param {Object} commonOverrides - Overrides applied to all products
 */
export function createProducts(count, commonOverrides = {}) {
  return Array.from({ length: count }, () => createProduct(commonOverrides));
}

/**
 * Create a settings document for exchange rate testing.
 * @param {number} rate - USD to ILS exchange rate
 */
export function createSettings(rate = 3.70) {
  return {
    _id: new mongoose.Types.ObjectId(),
    exchangeRate: rate,
    exchangeRateUpdatedAt: new Date(),
    siteName: 'Test Store'
  };
}

/**
 * Create a mock order object.
 * @param {Object} options - Order options
 */
export function createOrder({
  userId,
  products = [],
  totalUsd = 100,
  totalIls = 370,
  status = 'pending',
  paymentMethod = 'paypal'
} = {}) {
  counter++;
  return {
    _id: new mongoose.Types.ObjectId(),
    orderId: `ORDER-${counter.toString().padStart(6, '0')}`,
    userId: userId || new mongoose.Types.ObjectId(),
    products,
    totalUsd,
    totalIls,
    status,
    paymentMethod,
    createdAt: new Date()
  };
}
```
  </action>
  <verify>
File exists at backend/tests/helpers/factories.js.

Syntax check:
```bash
cd backend
node -e "const f = require('./tests/helpers/factories.js'); console.log(f.createProduct().name)"
```
Should output something like "Test Product 1".
  </verify>
  <done>
Factory functions created:
- createProduct, createUser, createAdmin with unique IDs and names
- createProducts for batch creation
- createCartItem, createSettings, createOrder for related entities
- resetFactoryCounter for predictable test sequences
  </done>
</task>

<task type="auto">
  <name>Task 3: Add test cleanup automation to setup</name>
  <files>backend/tests/setup.js</files>
  <action>
Update backend/tests/setup.js to add afterEach cleanup hooks:

1. Import clearDatabase from './helpers/db.js'
2. Import resetFactoryCounter from './helpers/factories.js'
3. Import cleanAllMocks from './helpers/mocks/index.js' (if it exists, otherwise skip for now)

Add afterEach hook:
```javascript
afterEach(async () => {
  // Clear all database collections between tests
  await clearDatabase();

  // Reset factory counter for predictable data
  resetFactoryCounter();

  // Clear any HTTP mocks (if using nock)
  // cleanAllMocks(); // Uncomment after mocks module exists
});
```

Update the clearDatabase function in db.js if needed:
```javascript
export async function clearDatabase() {
  const collections = mongoose.connection.collections;
  for (const key in collections) {
    await collections[key].deleteMany({});
  }
}
```

This ensures:
- Each test starts with empty database
- Factory counters reset (predictable sequences)
- No HTTP mock leakage between tests
  </action>
  <verify>
Run tests to confirm cleanup doesn't break existing tests:
```bash
cd backend && npm test
```

Verify cleanup works by checking two tests don't share data:
- Add a quick test that creates data and another that checks data is gone
  </verify>
  <done>
Test cleanup automation configured:
- afterEach clears all database collections
- Factory counters reset between tests
- Each test runs in clean isolation
  </done>
</task>

</tasks>

<verification>
1. `cd backend && npm test` - All tests pass
2. Fixtures can be imported: `import { mockProduct, mockUser } from './helpers/fixtures/index.js'`
3. Factories create unique data: `createProduct().name !== createProduct().name`
4. Tests are isolated: data from one test doesn't appear in another
5. afterEach hooks execute without errors
</verification>

<success_criteria>
- Product fixtures provide consistent mock products with various scenarios
- User fixtures provide regular user, admin, and cart scenarios
- Factory functions create unique test data on each call
- afterEach hooks clear database between tests
- Factory counter resets for predictable test sequences
- All fixtures and factories are importable from central index
</success_criteria>

<output>
After completion, create `.planning/phases/10-test-infrastructure-foundation/10-05-SUMMARY.md`
</output>

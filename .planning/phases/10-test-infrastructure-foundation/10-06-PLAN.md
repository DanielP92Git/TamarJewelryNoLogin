---
phase: 10-test-infrastructure-foundation
plan: 06
type: execute
wave: 3
depends_on: ["10-01", "10-03", "10-04", "10-05"]
files_modified:
  - backend/tests/integration/sample.integration.test.js
  - backend/package.json
autonomous: true

must_haves:
  truths:
    - "Sample integration test makes HTTP request to Express app"
    - "Integration test uses in-memory MongoDB (not production)"
    - "Integration test uses mocked external APIs (no real PayPal/Stripe calls)"
    - "Test passes without any production resource contamination"
  artifacts:
    - path: "backend/tests/integration/sample.integration.test.js"
      provides: "Sample integration test demonstrating infrastructure"
      contains: "supertest"
  key_links:
    - from: "backend/tests/integration/sample.integration.test.js"
      to: "backend/index.js"
      via: "supertest request"
      pattern: "request.*app"
    - from: "backend/tests/integration/sample.integration.test.js"
      to: "mongodb-memory-server"
      via: "mongoose connection"
      pattern: "mongoose.connection"
---

<objective>
Create a sample integration test that demonstrates all infrastructure components working together.

Purpose: Verify the complete test infrastructure (Vitest, mongodb-memory-server, nock mocks, fixtures) by creating a real integration test that tests an API endpoint end-to-end.
Output: Working integration test that serves as a template for Phase 11-16 test development.
</objective>

<execution_context>
@C:\Users\pagis\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\pagis\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/10-test-infrastructure-foundation/10-CONTEXT.md

# Prior plan outputs needed
@.planning/phases/10-test-infrastructure-foundation/10-01-SUMMARY.md
@.planning/phases/10-test-infrastructure-foundation/10-03-SUMMARY.md
@.planning/phases/10-test-infrastructure-foundation/10-04-SUMMARY.md
@.planning/phases/10-test-infrastructure-foundation/10-05-SUMMARY.md

# Backend app for integration testing
@backend/index.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install supertest for HTTP integration testing</name>
  <files>backend/package.json</files>
  <action>
Install supertest as dev dependency:
```bash
cd backend
npm install --save-dev supertest
```

Supertest allows making HTTP requests to Express apps without starting a server on a port. This enables true integration testing of API endpoints.

Do NOT modify any existing scripts or dependencies.
  </action>
  <verify>
Run `npm ls supertest` in backend directory - supertest listed.
  </verify>
  <done>
Supertest installed for HTTP integration testing.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create app export for testing</name>
  <files>backend/index.js</files>
  <action>
The backend index.js currently starts the server immediately. For testing, we need to export the Express app without starting the server.

Check if the app is already exported at the bottom of index.js. If not, add:

```javascript
// Export app for testing (at the very end of the file)
export { app };
// or for CommonJS:
// module.exports = { app };
```

If the file uses CommonJS (require/module.exports), use that pattern.
If the file uses ES modules (import/export), use that pattern.

The key is to export `app` so tests can import it without the server listening on a port.

IMPORTANT: Do NOT change how the server starts in production. Only add the export. The existing `app.listen()` should remain unchanged.

If the file already has `export { app }` or `module.exports.app`, skip this modification.
  </action>
  <verify>
Check that app is exported:
```bash
cd backend
node -e "const { app } = require('./index.js'); console.log(typeof app)"
```
Should output "function" (Express app is a function).

Note: This may start the server briefly during the check. That's okay for verification.
  </verify>
  <done>
Express app exported for test imports.
Existing server startup behavior unchanged.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create sample integration test</name>
  <files>backend/tests/integration/sample.integration.test.js</files>
  <action>
Create backend/tests/integration/sample.integration.test.js:

```javascript
/**
 * Sample Integration Test
 * Demonstrates the test infrastructure working together:
 * - Vitest test runner
 * - mongodb-memory-server for isolated database
 * - nock for external API mocking
 * - supertest for HTTP requests
 * - fixtures and factories for test data
 *
 * Use this as a template for Phase 11-16 integration tests.
 */
import { describe, it, expect, beforeAll, afterAll, beforeEach } from 'vitest';
import request from 'supertest';
import mongoose from 'mongoose';

// Import fixtures and factories
import { mockProduct, mockUser } from '../helpers/fixtures/index.js';
import { createProduct, createUser } from '../helpers/factories.js';

// Import mock utilities
import {
  disableNetConnect,
  cleanAllMocks,
  mockExchangeRateAPI
} from '../helpers/mocks/index.js';

// Import environment guard to verify safety
import { validateTestEnvironment } from '../helpers/envGuard.js';

describe('Sample Integration Test - Infrastructure Verification', () => {
  let app;

  beforeAll(async () => {
    // Verify we're in safe test environment
    validateTestEnvironment();

    // Disable real HTTP requests (only allow localhost for supertest)
    disableNetConnect();

    // Import app after environment is validated
    // Dynamic import to ensure setup.js runs first
    const appModule = await import('../../index.js');
    app = appModule.app;
  });

  afterAll(async () => {
    cleanAllMocks();
  });

  beforeEach(async () => {
    // Clear mocks between tests
    cleanAllMocks();
  });

  describe('Database Isolation', () => {
    it('should be connected to in-memory MongoDB', () => {
      expect(mongoose.connection.readyState).toBe(1);
      // Memory server uses 127.0.0.1
      expect(mongoose.connection.host).toBe('127.0.0.1');
    });

    it('should be able to save and retrieve data', async () => {
      // Use Product model from the app
      const Product = mongoose.model('Products');

      // Create test product using factory
      const productData = createProduct({ name: 'Integration Test Product' });
      const product = new Product(productData);
      await product.save();

      // Verify it was saved
      const found = await Product.findById(product._id);
      expect(found).toBeDefined();
      expect(found.name).toBe('Integration Test Product');
    });
  });

  describe('API Endpoint Testing', () => {
    it('should respond to health check or root endpoint', async () => {
      // Test a simple endpoint - adjust based on actual routes
      const response = await request(app)
        .get('/api/products')
        .expect('Content-Type', /json/);

      // Should return 200 with array (empty or with products)
      expect(response.status).toBe(200);
      expect(Array.isArray(response.body) || response.body.products).toBeTruthy();
    });

    it('should return products from test database', async () => {
      // Seed test data
      const Product = mongoose.model('Products');
      const productData = createProduct({
        name: 'API Test Product',
        category: 'necklaces',
        usdPrice: 99
      });
      await new Product(productData).save();

      // Request products
      const response = await request(app)
        .get('/api/products')
        .expect(200);

      // Verify our test product appears
      const products = response.body.products || response.body;
      const found = products.find(p => p.name === 'API Test Product');
      expect(found).toBeDefined();
      expect(found.usdPrice).toBe(99);
    });
  });

  describe('External API Mocking', () => {
    it('should use mocked exchange rate API', async () => {
      // Mock exchange rate API with known rate
      mockExchangeRateAPI(4.00); // 1 USD = 4 ILS for test

      // If there's an endpoint that uses exchange rates, test it here
      // For now, just verify the mock was set up
      // The actual exchange rate tests will be in Phase 13

      // This demonstrates that external APIs are mocked
      expect(true).toBe(true); // Placeholder - real test in Phase 13
    });
  });

  describe('No Production Contamination', () => {
    it('should not have production MongoDB URL in environment', () => {
      const mongoUrl = process.env.MONGO_URL || '';
      expect(mongoUrl).not.toContain('mongodb.net');
      expect(mongoUrl).not.toContain('mongodb+srv');
    });

    it('should not have live Stripe key in environment', () => {
      const stripeKey = process.env.STRIPE_SECRET_KEY || '';
      expect(stripeKey).not.toMatch(/^sk_live_/);
    });

    it('should not have live PayPal URL in environment', () => {
      const paypalUrl = process.env.PAYPAL_BASE_URL || '';
      expect(paypalUrl).not.toBe('https://api-m.paypal.com');
    });
  });
});
```

Note: This test may need adjustments based on:
- Actual route paths in backend/index.js
- Whether the app uses ES modules or CommonJS
- Exact model names (Products vs Product)

The key is demonstrating that all infrastructure pieces work together.
  </action>
  <verify>
Run the integration test:
```bash
cd backend && npm test -- tests/integration/sample.integration.test.js
```

All tests should pass. If any fail due to route/model differences, adjust the test accordingly.
  </verify>
  <done>
Sample integration test created demonstrating:
- Database isolation with mongodb-memory-server
- HTTP endpoint testing with supertest
- External API mocking with nock
- Environment safety validation
- No production contamination
  </done>
</task>

</tasks>

<verification>
1. `cd backend && npm test` - All tests pass including integration test
2. Integration test verifies mongodb-memory-server is used (127.0.0.1 host)
3. Integration test makes HTTP requests to Express app
4. Integration test verifies no production credentials present
5. Test output shows no warnings about external API calls
</verification>

<success_criteria>
- supertest installed for HTTP integration testing
- Express app exported for test imports
- Sample integration test demonstrates full infrastructure:
  - Database operations work with in-memory MongoDB
  - HTTP requests work with supertest
  - External APIs can be mocked
  - Environment safety is validated
- Integration test passes without any production resource access
- Test serves as template for Phase 11-16 test development
</success_criteria>

<output>
After completion, create `.planning/phases/10-test-infrastructure-foundation/10-06-SUMMARY.md`
</output>
